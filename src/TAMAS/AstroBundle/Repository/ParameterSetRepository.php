<?php
namespace TAMAS\AstroBundle\Repository;


use TAMAS\AstroBundle\DISHASToolbox\QueryGenerator as QG;
use TAMAS\AstroBundle\DISHASToolbox\Table\TAMASListTableTemplate;
use TAMAS\AstroBundle\Entity as E;
use Doctrine\ORM as Doctrine;

/**
 * ParameterSetRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ParameterSetRepository extends Doctrine\EntityRepository
{

    /* ___________________________________________________________________General ______________________________________________________________________________ */
    static public function mySort($a, $b)
    {
        if ((float) $a->getValueFloat() < (float) $b->getValueFloat()) {
            return - 1;
        } elseif ((float) $a->getValueFloat() == (float) $b->getValueFloat()) {
            return 0;
        } else {
            return 1;
        }
    }


    /* _________________________________________________________ add data ______________________________________ */

    /**
     * prepareListForForm
     *
     * This method is used when the current entity is linked to a parent form.
     * It returns a custom DQL query builder (not the result!) which will be queried from the formType and findForAutofill.
     *
     * @param {boolean} $option
     * @return Doctrine\QueryBuilder
     */
    public function prepareListForForm($option)
    {
        if ($option) {
            $result = $this->createQueryBuilder('p')
                ->leftJoin('p.tableType', 't')
                ->addSelect('t')
                ->leftJoin('t.astronomicalObject', 'a')
                ->addSelect('a')
                ->leftJoin('p.parameterValues', 'pv')
                ->addSelect('pv')
                ->leftJoin('p.tableContents', 'tc')
                ->addSelect('tc')
                ->leftJoin('tc.editedText', 'et')
                ->addSelect('et')
                ->leftJoin('p.createdBy', 'c')
                ->addSelect('c')
                ->where('t.id = :id')
                ->setParameter('id', $option)
                ->orderBy('a.id, t.tableTypeName, p.id');
        } else {
            $result = $this->createQueryBuilder('p')
                ->leftJoin('p.tableType', 't')
                ->addSelect('t')
                ->leftJoin('t.astronomicalObject', 'a')
                ->addSelect('a')
                ->leftJoin('p.parameterValues', 'pv')
                ->addSelect('pv')
                ->leftJoin('p.tableContents', 'tc')
                ->addSelect('tc')
                ->leftJoin('tc.editedText', 'et')
                ->addSelect('et')
                ->leftJoin('p.createdBy', 'c')
                ->addSelect('c')
                ->orderBy('a.id, t.tableTypeName, p.id');
        }
        return $result;
  
    }



    /**
     * findForAutofill
     *
     * This method is triggered in the parent entity form type by ajax. It returns the getLabeld list of object of the entity class. In some case an option can be passed to modify the query to the database.
     * For instance, we can pass the parameterSet.tableType.id to query specific object depending on the tableType identifier.
     *
     * @param $option : the identifier of a table type.
     * @return array : each value of the array contains an id and a title which are used in the ajax request to populate the select choice of the form such as <selec><option = "id">title</option>.
     */
    public function findForAutofill($option)
    {
        $entities = $this->prepareListForForm($option)
            ->getQuery()
            ->getResult();
        $answers = [];
        foreach ($entities as $entity) {
            $answers[] = [
                "id" => $entity->getId(),
                "title" => (string) $entity
            ];
        }
        return $answers;
    }

    /* __________________________________________________ list data ___________________________________________________ */

    /**
     * getList
     *
     * This method is roughly equivalent to findAll(), but it lowers the number of queries to the database.
     *
     *
     * @return array of object edited texts
     */
    public function getList()
    {
        return $this->prepareListForForm(false)
            ->getQuery()
            ->getResult();
    }

    /**
     * getFormattedList
     *
     * This method formats an array of a given entity objects in order to show it on a list (a table in our twig interface).
     * This format is not an easy task from the front-end, and is much easier when it is possible to call other method from different repository (e.g. : getLabel).
     * Hence, this method lowers the number of code line / the number of query to the database / make the method mutualized and so lower the amont of mistake in case of evolution of the code.
     *
     * @param array $parameterSets
     *            (objects).
     * @return array of formatted $parameterSet properties
     */
    public function getFormatedList($parameterSets)
    {
        $formatedParameterSets = [];
        if (empty($parameterSets)) {
            return $formatedParameterSets;
        }
        foreach ($parameterSets as $parameterSet) {
            $id = $parameterSet->getId();
            $title = [
                'id' => $id,
                'entity' => 'parameterSet'
            ];
            $values = $parameterSet->getTitle();
            $tableContents = [];
            $tableType = "";
            $created = "";
            $updated = "";
            $createdBy = [];
            $updatedBy = [];
            if ($parameterSet->getCreatedBy()) {
                $createdBy = [
                    'id' => $parameterSet->getCreatedBy()->getId(),
                    'username' => $parameterSet->getCreatedBy()->getUserName()
                ];
            }
            if ($parameterSet->getUpdatedBy()) {
                $updatedBy = [
                    'id' => $parameterSet->getUpdatedBy()->getId(),
                    'username' => $parameterSet->getUpdatedBy()->getUsername()
                ];
            }
            if ($parameterSet->getCreated()) {
                $created = $parameterSet->getCreated();
            }
            if ($parameterSet->getUpdated()) {
                $updated = $parameterSet->getUpdated();
            }
            if ($parameterSet->getTableType()) {
                $tableType = (string)$parameterSet->getTableType(); 
            }
            if (! empty($parameterSet->getTableContents()->toArray())) {
                foreach ($parameterSet->getTableContents() as $tableContent) {
                    $tableContents[] = [
                        'id' => $tableContent->getId(),
                        'entity' => 'tableContent',
                        'title' => (string) $tableContent,
                        'public' => $tableContent->getPublic()
                    ];
                }
            }
            $title['title'] = $tableType . " n° " . $id;
            $formatedParameterSets[] = [
                'id' => $id,
                'title' => $title,
                'tableType' => $tableType,
                'values' => $values,
                'tableContents' => $tableContents,
                'createdBy' => $createdBy,
                'updatedBy' => $updatedBy,
                'created' => $created->format('d-m-Y'),
                'updated' => $updated->format('d-m-Y')
            ];
        }
        return $formatedParameterSets;
    }

    /**
     * getObjectList
     *
     * This function generates the specs for listing a given collection of editedTexts: both the list of data (pre-treated for the front library) and the spec of the table (adapted to the front library).
     *
     * @param array $parameterSets : collection of all the parameterSets to be listed
     * @return array : containing the list of fields and the list of data ;
     */
    public function getObjectList($parameterSets, \TAMAS\AstroBundle\DISHASToolbox\Table\TAMASListColumnSpec $spec)
    {
        $paramName = ucfirst(E\ParameterSet::getInterfaceName());
        $tableContentName = E\TableContent::getInterfaceName();
        $fieldList = [
            new TAMASListTableTemplate('id', '#'),
            new TAMASListTableTemplate('title', "$paramName", ['class'=>['link']]),
            new TAMASListTableTemplate('values', 'Values'),
            new TAMASListTableTemplate('tableContents', "Associated $tableContentName in edition",['class'=>['link', 'list']]),
            new TAMASListTableTemplate('created', 'Created', [] , 'adminInfo'),
            new TAMASListTableTemplate('updated', 'Updated', [], 'adminInfo'),
            new TAMASListTableTemplate('buttons', '', [], 'editDelete')
        ];

        $data = $this->getFormatedList($parameterSets);

        return [
            'fieldList' => $fieldList,
            'data' => $data
        ];
    }

    /* ______________________________________________________________ prepare data for form ________________________________________________________________ */

    /**
     * createParameterSet
     *
     * This method creates well-formed parameterSet object according to its tableType. It is called by method adminAddParameterSetAction() from AdminController.
     * Depending on the tableType of the parameterSet, we attribute the correct number of parameterValue associated with the correct parameterFormat.
     * This object is ready to be passed to the parameterSet form type which will be adapted to the parameterFormat attributed to the children parameterValue.
     *
     * @param integer $tableTypeId
     * @return object $parameterSet
     */
    public function createParameterSet($tableTypeId)
    {
        if (! $tableTypeId) {
            return null;
        }
        $tableType = $this->getEntityManager()
            ->getRepository(E\TableType::class)
            ->find($tableTypeId);
        $parameterSet = new E\ParameterSet();
        $parameterSet->setTableType($tableType);
        $parameterFormats = $this->getEntityManager()
            ->getRepository(E\ParameterFormat::class)
            ->findBy([
            'tableType' => $tableTypeId
        ]);
        foreach ($parameterFormats as $format) {
            $parameterValue = new E\ParameterValue();
            $parameterValue->setParameterFormat($format);
            $parameterSet->addParameterValue($parameterValue);
        }
        return $parameterSet;
    }

    /* _____________________________________________________ search data ________________________________________________________________ */

    /**
     * findParameterSetByValue
     *
     * This method is called by the method adminSearchParameterSetAction() of Admin Controller
     * It finds objects of class parameterSet depending on their parameterValues.
     * It only deals with entered values, doesn't check blank fields.
     * It returns 2 different cases : a) there is a list of one or many results (returns array of parameterSet) ; b) there is no result (returns false).
     *
     * @param object $parameterSet
     * @param object $flashBag
     * @return array (or boolean null)
     */
    public function findParameterSetByValue($parameterSet, $flashBag)
    {
        $parameterSets = array();
        $thatTableType = $parameterSet->getTableType();
        foreach ($parameterSet->getParameterValues() as $value) {
            if (! $value->checkIfNull()) {
                $parameterSets[] = $this->getEntityManager()
                    ->getRepository(E\ParameterValue::class)
                    ->findForParameterSet($value, $thatTableType, 'search');
            }
        }
        if (count($parameterSets) > 1) {
            $intersects = call_user_func_array('array_intersect', $parameterSets);
            // We only keep the id when the 2 arrays contain the same.
        } else {
            $intersects = array_shift($parameterSets);
        }
        if (count($intersects) == 0) {
            $flashBag->add("warning", "No result found in the database. Please try a new search.");
            return null;
        }
        return $intersects;
    }

    /**
     * findParameterSetBySingleValue
     *
     * This method is called by adminListSimpleSearchParameterSetAction. Depending on a string value (the needle of the search) and the option (stars with, finishes with, contains) it returns a list of matching parameterSet objects.
     *
     * @param string $value
     * @param string $option
     * @return array
     */
    public function findParameterSetBySingleValue($value, $option)
    {
        if (! $value || $value == null) {
            return [];
        }
        $em = $this->getEntityManager();
        $parameterValueRep = $em->getRepository(E\ParameterValue::class);
        $parameterSetIds = $parameterValueRep->findForParameterSetBySingleValue($value, $option);
        $parameterSets = [];
        foreach ($parameterSetIds as $parameterSetId) {
            $parameterSets[] = $this->find($parameterSetId);
        }
        return $this->getFormatedList($parameterSets);
    }

    /**
     * hasDuplicate
     *
     * This method is called by admin controller addParameterSetAction().
     * It checks that the new object of class ParameterSet doesn't have a duplicate in the database, depending on its table type and its values.
     * It returns 3 different cases : a) the parameterSet has no duplicate (returns false) ; b) the parameterSet has one duplicate (returns true) ; c) the parameterSet has more than one duplicate (returns false).
     * It deals with the creation of warning flashbags.
     *
     * @param object $parameterSet
     * @param object $flashBag
     * @return boolean (true means that the parameterSet has one duplicate, false means that it doesn't)
     */
    public function hasDuplicate($parameterSet, $flashBag)
    {
        $thatTableType = $parameterSet->getTableType();
        $parameterSets = [];
        foreach ($parameterSet->getParameterValues() as $value) {
            $parameterSets[] = $this->getEntityManager()
                ->getRepository(E\ParameterValue::class)
                ->findForParameterSet($value, $thatTableType, 'findDuplicate');
        }
        if (count($parameterSets) > 1) {
            $intersect = call_user_func_array('array_intersect', $parameterSets); // We only keep the id when the 2 arrays contain the same.
        } else {
            $intersect = array_shift($parameterSets);
        }
        if (count($intersect) == 0) {
            return false;
        } else if (count($intersect) == 1) {
            foreach ($intersect as $id) { // we can't be sure that the correct value is array[0]
                $thatId = $id;
            }
            if ($parameterSet->getId() == $thatId) { // In case of edition, we still need to check if the edited document is a duplicate of another parameter set, but we don't want to compare it with itself
                return false;
            }
            $flashBag->add("warning", "This resource is already in the database (id: $thatId).");
            return true;
        } else if (count($intersect) > 1) {
            $parameterSetId = " ";
            foreach ($intersect as $thatId) {
                $parameterSetId = $parameterSetId . " n°" . $thatId;
            }
            $flashBag->add("danger", "This resource already has a duplicate in the database. Please contact IT and give the following ID of parameter set to fix this issue " . $parameterSetId);
            return true;
        }
        return false;
    }

    /**
     * getDependencies
     *
     * This method is part of the process of forcing deletion of an object.
     * We need to know what are the related fields that are linked to place (in order to unlink it before deleting it)
     *
     * @return array
     */
    public function getDependancies()
    {
        return [
            E\ParameterValue::class => [
                'parameterSet' => [
                    'unlinkMethod' => 'setParameterSet',
                    'oneToMany' => true
                ]
            ],
            E\TableContent::class => [
                'parameterSets' => [
                    'unlinkMethod' => 'removeParameterSet',
                    'oneToMany' => false
                ]
            ]
        ];
    }

    public function getJson($astronomicalParam)
    {
        $tableau = [];
        foreach($astronomicalParam->getParameterValues() as $parameterValue) {
            $param_id = $parameterValue->getParameterFormat()->getId();
            $value = $parameterValue->getValueFloat();
            $tableau[$param_id] = $value;
        }
        return json_encode($tableau);
    }

    /**
     * Returns a field list used in the results page in the front office
     * in order to generates a DataTable of the results on a query to elasticsearch
     *
     * The name provides the location in an array where DataTable will find the information to display
     *
     * The title corresponds to the column label associated with the information
     *
     * The properties defines how the cell content will be formatted :
     * 		- class (will surround the text in a <span class="__"></span>) :
     * 			* number : in order to align the text to the right
     * 			* title-italic : to style the text of the cell in italic
     *          * uppercase : to style the text of the cell in uppercase letter
     *          * truncate : truncate all strings superior to 120 characters
     *          * capitalize : capitalize the first letter of the string
     * 		- path + id :
     * 			* path : routing path to generate a link
     * 			* id : location of the id in the result object
     * 		- unknown : text to display if there is no information provided in the results)
     *
     * Source defines which fields will appear in the elasticsearch response
     * corresponding to the fields that are added to the array associated with the key "source" in the query
     * (multiple fields can be added for a single column with "+")
     *
     * @return array of TAMASListTableTemplate objects
     */
    public function getPublicObjectList()
    {
        return [
            new TAMASListTableTemplate('id', '#'),
            new TAMASListTableTemplate('table_type', 'Title',
                ['path' => 'tamas_astro_viewParameterSet', 'id' => 'id'],
                '', 'table_type.kibana_name'),
            new TAMASListTableTemplate('default_title', 'Value(s) (original)', ['class'=>['number'], 'unknown'=>'No value provided']),
            new TAMASListTableTemplate('values', 'Value details (float)', ['unknown'=>'No value provided'],"","parameter_values.default_title"),
            new TAMASListTableTemplate('type_definition', ucfirst(E\TableType::getInterfaceName()." definition"),
                ['class'=>['ucfirst']],'', 'table_type.astro_definition'),
            new TAMASListTableTemplate('editions', ucfirst(E\EditedText::getInterfaceName(true)),
                [
                    'path' => 'tamas_astro_viewTableEdition',
                    'id' => 'table_contents.edited_text.kibana_id',
                    'unknown'=>"No ".E\EditedText::getInterfaceName()." associated"
                ],'', 'table_contents.kibana_name+table_contents.edited_text.kibana_id')
        ];
    }

    /**
     * Returns an array of all the original items that are associated with an edited text
     * that uses the parameter set given as argument in its table contents
     *
     * @param E\ParameterSet $param
     * @return array
     */
    public function getOriginalTexts(E\ParameterSet $param){
        if (! $param)
            return [];
        if (! $param->getTableContents())
            return [];

        $editions = [];
        foreach ($param->getTableContents() as $content){
            if ($content->getEditedText()){
                $editions[] = $content->getEditedText();
            }
        }
        if (count($editions) == 0)
            return [];

        $editTextRepo = $this->getEntityManager()->getRepository(E\EditedText::class);
        $origItems = []; $origIds = [];
        foreach ($editions as $edition){
            foreach ($editTextRepo->getOriginalTexts($edition) as $text){
                if ($text->getPublic()){
                    if (!in_array($text->getId(),$origIds)){
                        $origItems[] = $text;
                        $origIds[] = $text->getId();
                    }

                }
            }
        }
        return $origItems;
    }


    /**
     * this methods returns a dataset that can be used to generate a chrono map to visualize
     * where the parameter set given as argument has been used in original items
     *
     * @param E\ParameterSet $param
     * @return array
     */
    public function getChronoMapData(E\ParameterSet $param)
    {
        $origItems = $this->getOriginalTexts($param);
        // Check if there is original items associated with the parameter set
        if (count($origItems) == 0)
            return [];


        $boxesData = [];
        $mapData = [];
        $timeData = [];
        $origItemRepo = $this->getEntityManager()->getRepository(E\OriginalText::class);
        foreach ($origItems as $item){
            $boxesData["oi".$item->getId()] = $origItemRepo->getBoxData($item, false);
            $mapData = $origItemRepo->getPlaceData($item, $mapData, ["originalText" => []]);
            $timeData = $origItemRepo->getTimeData($item, $timeData, ["originalText"]);
        }

        if (count($timeData) != 0) {
            $minDate = min(array_keys($timeData)) - 20;
            $maxDate = max(array_keys($timeData)) + 20;

            for ($date = $minDate; $date <= $maxDate; $date += 10) {
                if (!isset($timeData[$date])) {
                    $timeData[$date] = ["year" => $date, "i" => "i", "ids" => [], "originalText" => 0];
                }
            }

            ksort($timeData);
        }

        return [
            "chart" => [
                ["type" => "Heatmap",
                 "data" => $timeData],
                ["type" => "Map",
                 "data" => $mapData]
            ],
            "box" => $boxesData
        ];
    }

    /**
     * This method generates the metadata associated with a record of a parameter set
     * in order to be displayed in a box
     * @param E\ParameterSet $param
     * @return array
     */
    public function getBoxData(E\ParameterSet $param) {

        $paramName = ucfirst(E\ParameterSet::getInterfaceName());
        $tableType = $param->getTableType() ? ucfirst($param->getTableType()->getTableTypeName()) : null;
        $astroObject = $tableType ? ucfirst($param->getTableType()->getAstronomicalObject()->getObjectName()) : null;
        $title = $tableType ? "$astroObject | $tableType parameter" : "$paramName n°".$param->getId();

        $formats = "";
        $units = "";
        $i = 0;
        foreach ($param->getParameterValues() as $value){
            $sep = $i == count($param->getParameterValues())-1 ? "" : " | ";

            $paramFormat = $value->getParameterFormat() ? $value->getParameterFormat() : null;
            $format = $paramFormat ? str_replace("$tableType: ","",$paramFormat->toPublicString()) : "<span class='noInfo'>Unknown parameter format</span>";
            $format = str_replace("imum", ".", $format);
            $formats = $formats.ucfirst($format).$sep;

            if ($i == 0){
                $typeNb = $value->getTypeOfNumber() ? ucfirst($value->getTypeOfNumber()->getTypeName()) : "<span class='noInfo'>Unknown type of number</span>";
                $units = "$units$typeNb";
            }
            $i++;
        }

        return [
            "id" => $param->getId(),
            "object" => $astroObject,
            "title" => $title,
            "format" => $formats,
            "value" => $param->getStringValues(),
            "unit" => $units
        ];
    }

    /**
     * This method returns the metadata associated with the astronomical context of an edition
     * @param E\ParameterSet $param
     * @return array
     * @throws \Exception
     */
    public function getMetadataTable(E\ParameterSet $param)
    {
        $metadata = [];
        $metadata["entity"] = "parameter_set";

        $metadataTable = ["val" => "", "search" => ["json" => "", "hover" => "", "title" => ""]];

        // it is mandatory to add an empty string to the values property if we want to display "No information provided" when metadata is missing

        /* PARAMETER SET HEADER */
        $paramName = E\ParameterSet::getInterfaceName();
        $paramNames = E\ParameterSet::getInterfaceName(true);
        $metadata["title"] = ucfirst($paramName)." n°".$param->getId();

        /* RELATED EDITIONS */
        $metadata["edition"] = "table_contents.kibana_name+table_contents.edited_text.kibana_id";
        /*$filter = QG::newMatchFilter("table_contents.parameter_sets.id", $param->getId());
        $editedTextName = E\EditedText::getInterfaceName(true);
        $metadata["edition"] = [
            "json" => QG::setFilters([$filter]),
            "hover" => "Find all the $editedTextName using this parameter set",
            "title" => "All the $editedTextName using the $paramName n°".$param->getId()];*/

        /* TABLE TYPE */
        if ($param->getTableType()){
            $typeName = E\TableType::getInterfaceName();
            $metadata["subtitle"] = $metadataTable;
            $metadata["subtitle"]["val"] = $param->getTableType()->toPublicString();
            $metadata["subtitle"]["search"]["hover"] = "All $paramNames that belong to the same $typeName";
            $metadata["subtitle"]["search"]["title"] = "All $paramNames that are associated with ".$param->getTableType()->getTableTypeName();

            $filter = QG::newMatchFilter("table_type.id", $param->getTableType()->getId());
            $metadata["subtitle"]["search"]["json"] = QG::setFilters([$filter]);
        }

        /* PARAMETER VALUES */
        $paramValues = $param->getParameterValues()->toArray();
        if (count($paramValues) != 0) {
            $metadata["value"] = [];
            foreach ($paramValues as $value){
                $valueMetadata = [];

                /* PARAMETER FORMAT */
                $valueMetadata["th"] = $metadataTable;
                $valueMetadata["th"]["val"] = $value->getParameterFormat() ? $value->getParameterFormat()->toPublicString() : "<span class='noInfo'>Unnamed parameter</span>";
                if ($value->getParameterFormat()){
                    $valueMetadata["th"]["search"]["hover"] = "All $paramNames that use the same parameter";
                    $valueMetadata["th"]["search"]["title"] = "All $paramNames that use « ".$value->getParameterFormat()->toPublicString()." » as parameter";

                    $filter = QG::newMatchFilter("parameter_values.parameter_format.id", $value->getParameterFormat()->getId());
                    $valueMetadata["th"]["search"]["json"] = QG::setNestedFilters("parameter_values", [$filter]);
                }

                /* VALUE ORIGINAL & DECIMAL (+ type of number) */
                $valueMetadata["value"] = $metadataTable;
                $valueMetadata["value"]["val"] = $value->toPublicTitle();


                /* RANGE1 INITIAL (original) */
                if ($value->getRange1InitialOriginalBase()){
                    $valueMetadata["low bound (1)"] = $metadataTable;
                    $valueMetadata["low bound (1)"]["val"] = $value->getRange1InitialOriginalBase();
                }

                /* RANGE1 FINAL (original) */
                if ($value->getRange1FinalOriginalBase()){
                    $valueMetadata["high bound (1)"] = $metadataTable;
                    $valueMetadata["high bound (1)"]["val"] = $value->getRange1FinalOriginalBase();
                }

                /* RANGE2 INITIAL (original) */
                if ($value->getRange2InitialOriginalBase()){
                    $valueMetadata["low bound (2)"] = $metadataTable;
                    $valueMetadata["low bound (2)"]["val"] = $value->getRange2InitialOriginalBase();
                }

                /* RANGE2 FINAL (original) */
                if ($value->getRange2FinalOriginalBase()){
                    $valueMetadata["high bound (2)"] = $metadataTable;
                    $valueMetadata["high bound (2)"]["val"] = $value->getRange2FinalOriginalBase();
                }

                /* PARAMETER UNIT */
                if ($value->getParameterFormat()){
                    if ($value->getParameterFormat()->getParameterUnit()){
                        $valueMetadata["parameter unit"] = $metadataTable;
                        $valueMetadata["parameter unit"]["val"] = $value->getParameterFormat()->getParameterUnit()->getUnit();
                    }
                }

                /* TYPE OF NUMBER */
                if ($value->getTypeOfNumber()){
                    $valueMetadata["type of number"] = $metadataTable;
                    $valueMetadata["type of number"]["val"] = $value->getTypeOfNumber()->getTypeName();
                }

                $metadata["value"][] = $valueMetadata;
            }
        }

        // TODO add creator username

        return $metadata;
    }
}
