<?php
namespace TAMAS\AstroBundle\Repository;

use TAMAS\AstroBundle\DISHASToolbox\QueryGenerator as QG;
use TAMAS\AstroBundle\DISHASToolbox\Table\TAMASListTableTemplate;
use TAMAS\AstroBundle\Entity as E;

/**
 * FormulaDefinitionRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class FormulaDefinitionRepository extends \Doctrine\ORM\EntityRepository
{
    public function prepareListForForm()
    {
        return $this->createQueryBuilder('f')->orderBy('f.name, m.tableType', 'ASC');
    }

    public function getList()
    {
        return $this->createQueryBuilder('m')
            ->getQuery()
            ->getResult();
    }

    /**
     * getFormattedList
     *
     * This method formats an array of a given entity objects in order to show it on a list (a table in our twig interface).
     * This format is not an easy task from the front-end, and is much easier when it is possible to call other method from different repository (e.g. : getLabel).
     * Hence, this method lowers the number of code line / the number of query to the database / make the method mutualized and so lower the amont of mistake in case of evolution of the code.
     *
     * @param $formulaDefinitions
     * @return array
     */
    public function getFormatedList($formulaDefinitions)
    {
        $formattedFormulaDefinitions = [];
        foreach ($formulaDefinitions as $formulaDefinition) {
            $name = [];
            $tableType = "";
            $updatedBy = [];
            $createdBy = [];
            $author = "";
            $created = "";
            $updated = "";

            $name = [
                'id' => $formulaDefinition->getId(),
                'entity' => 'formulaDefinition'
            ];
            if ($formulaDefinition->getCreated()) {
                $created = $formulaDefinition->getCreated();
            }
            if ($formulaDefinition->getUpdated()) {
                $updated = $formulaDefinition->getUpdated();
            }
            if ($formulaDefinition->getCreatedBy()) {
                $createdBy = [
                    'id' => $formulaDefinition->getCreatedBy()->getId(),
                    'username' => $formulaDefinition->getCreatedBy()->getUsername()
                ];
            }
            if ($formulaDefinition->getUpdatedBy()) {
                $updatedBy = [
                    'id' => $formulaDefinition->getUpdatedBy()->getId(),
                    'username' => $formulaDefinition->getUpdatedBy()->getUsername()
                ];
            }
            if ($formulaDefinition->getName()) {
                $name['title'] = $formulaDefinition->getName();
            } else {
                $name['title'] = "Unknown text nÂ°" . $formulaDefinition->getId();
            }
            if ($formulaDefinition->getTableType()) {
                $tableType = (string) $formulaDefinition->getTableType(); 
            }
            if ($formulaDefinition->getAuthor()) {
                $author = (string) $formulaDefinition->getAuthor(); 
            }
            $formattedFormulaDefinitions[] = [
                'id' => $formulaDefinition->getId(),
                'created' => $created->format('d-m-Y'),
                'updated' => $updated->format('d-m-Y'),
                'name' => $name,
                'author' => $author,
                'tableType' => $tableType,
                'createdBy' => $createdBy,
                'updatedBy' => $updatedBy
            ];
        }
        return $formattedFormulaDefinitions;
    }

    /**
     * Returns a field list used in the results page in the front office
     * in order to generates a DataTable of the results on a query to elasticsearch
     *
     * The name provides the location in an array where DataTable will find the information to display
     *
     * The title corresponds to the column label associated with the information
     *
     * The properties defines how the cell content will be formatted :
     * 		- class (array of classes [] => will surround the text in a <span class="__"></span>) :
     * 			* number : in order to align the text to the right
     * 			* title-italic : to style the text of the cell in italic
     *          * uppercase : to style the text of the cell in uppercase letter
     *          * truncate : truncate all strings superior to 120 characters
     *          * capitalize : capitalize the first letter of the string
     * 		- path + id :
     * 			* path : routing path to generate a link
     * 			* id : location of the id in the result object
     * 		- unknown : text to display if there is no information provided in the results)
     *
     * Source defines which fields will appear in the elasticsearch response
     * corresponding to the fields that are added to the array associated with the key "source" in the query
     * (multiple fields can be added for a single column with "+")
     *
     * @return array of TAMASListTableTemplate objects
     */
    public function getPublicObjectList()
    {
        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);
        return [
            new TAMASListTableTemplate('id', '#'),
            new TAMASListTableTemplate('name', 'Title',
                ['class' => ['capitalize'], 'path' => 'tamas_astro_viewFormulaDefinition', 'id' => 'id', 'unknown' => 'Unnamed model']),
            new TAMASListTableTemplate('table_type_name', ucfirst($defRepo->getInterfaceName("tableType")), ['path' => 'tamas_astro_viewTableType', 'id' => 'id'],
            '','table_type.kibana_name+table_type.id'),
            new TAMASListTableTemplate('author', 'Author', [], '', 'author.kibana_name'),
            new TAMASListTableTemplate('explanation', 'Explanation',
                ['class' => ['truncate'],'unknown'=>'No explanation provided'])
        ];
    }

    /**
     * getObjectList
     *
     * This function generates the specs for listing a given collection of editedTexts: both the list of data
     * (pre-treated for the front library) and the spec of the table (adapted to the front library).
     *
     * @param array $formulaDefinitions : collection of all the edited texts to be listed
     * @return array : containing the list of fields and the list of data ;
     */
    public function getObjectList($formulaDefinitions)
    {
        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);
        $fieldList = [
            new TAMASListTableTemplate('id', '#'),
            new TAMASListTableTemplate('name', 'Name', ['class'=>['link']]),
            new TAMASListTableTemplate('tableType', ucfirst($defRepo->getInterfaceName("tableType"))),
            new TAMASListTableTemplate('author', 'Author', []),
            new TAMASListTableTemplate('created', 'Created', [], 'adminInfo'),
            new TAMASListTableTemplate('updated', 'Updated', [], 'adminInfo'),
            new TAMASListTableTemplate('buttons', '', [], 'editDelete')
        ];
        $data = $this->getFormatedList($formulaDefinitions);

        return [
            'fieldList' => $fieldList,
            'data' => $data
        ];
    }

    /**
     * @param E\FormulaDefinition $formulaDefinition
     * @return array
     */
    function getPublicObject(E\FormulaDefinition $formulaDefinition)
    {
        return [
            'id' => $formulaDefinition->getId(),
            'image' => $formulaDefinition->getImage(),
            'name' => $formulaDefinition->getName(),
            'author' => [
                'firstName' => $formulaDefinition->getAuthor()->getFirstName(),
                'lastName' => $formulaDefinition->getAuthor()->getLastName()
            ],
            'explanation' => $formulaDefinition->getExplanation(),
            'tip' => $formulaDefinition->getTip(),
            'formulaJson' => $formulaDefinition->getFormulaJson(),
            'parameterExplanation' => $formulaDefinition->getParameterExplanation(),
            'estimatorDefinition' => $formulaDefinition->getEstimatorDefinition(),
            'argNumber' => $formulaDefinition->getArgNumber(),
            'latexFormula' => $formulaDefinition->getLatexFormula(),
            'tableType' => $formulaDefinition->getTableType()
        ];
    }

    /**
     * This methods returns an array that can be use to generate a "box record" with the box template
     * @param E\FormulaDefinition $formulaDef
     * @return array
     */
    function getBoxData(E\FormulaDefinition $formulaDef){

        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);
        $formulaDefName = $defRepo->getInterfaceName("formulaDefinition");
        $tableTypeName = $defRepo->getInterfaceName("tableType");
        return [
            "id" => $formulaDef->getId(),
            "title" => $formulaDef->getName() ? $formulaDef->getName() : "<span class='noInfo'>Unnamed $formulaDefName</span>",
            "tableType" => $formulaDef->getTableType() ? ucfirst($formulaDef->getTableType()->getTableTypeName())." definition" : "Unknown $tableTypeName",
            "formula" => $formulaDef->toPublicString(),
        ];
    }

    public function getMetadataTable(E\FormulaDefinition $formula)
    {
        $metadata = [];
        $metadata["entity"] = "formula_definition";
        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);
        $formulaDefName = $defRepo->getInterfaceName("formulaDefinition", true);

        /* UPPER PART OF THE SIDEBAR */
        $metadata["title"] = $formula->toPublicTitle();

        $metadataTable = ["val" => [], "search" => ["json" => [], "hover" => "", "title" => []]];
        $urlTable = ["html" => "", "id" => "", "path" => ""];

        /* TABLE TYPE (astroObject + table type) */
        $tableTypeName = $defRepo->getInterfaceName("tableType");
        $metadata["$tableTypeName"] = $metadataTable;
        $type = $formula->getTableType();
        if ($type){
            $metadata["$tableTypeName"]["val"][] = $urlTable;
            $metadata["$tableTypeName"]["val"][0]["html"] = $type->toPublicString();
            $metadata["$tableTypeName"]["val"][0]["id"] = $type->getId();
            $metadata["$tableTypeName"]["val"][0]["path"] = "tamas_astro_viewTableType";

            $filter = QG::newMatchFilter("table_type.id", $type->getId());
            $metadata["$tableTypeName"]["search"]["json"][] = QG::setFilters([$filter]);
            $metadata["$tableTypeName"]["search"]["hover"] = "Find all $formulaDefName that belong to the same $tableTypeName";
            $metadata["$tableTypeName"]["search"]["title"][] = "All $formulaDefName whose subject is ".$type->toPublicTitle();
        }

        /* TABLE TYPE DEFINITION */
        if ($type){
            $metadata["$tableTypeName definition"] = $metadataTable;
            $metadata["$tableTypeName definition"]["val"][] = ucfirst($type->getAstroDefinition());
        }

        /* INTELLECTUAL AUTHOR */
        $historianName = $defRepo->getInterfaceName("historian");
        $metadata["$historianName"] = $metadataTable;
        $author = $formula->getAuthor();
        if ($author){
            $metadata["$historianName"]["val"] = [$author->toPublicString()];

            $filter = QG::newMatchFilter("author.kibana_id.keyword", "Historian".$author->getId());
            $metadata["$historianName"]["search"]["json"][] = QG::setFilters([$filter]);
            $metadata["$historianName"]["search"]["hover"] = "Find all $formulaDefName that were created by the same author";
            $metadata["$historianName"]["search"]["title"][] = "All $formulaDefName created by ".$author->toPublicString();
        }

        /* BIBLIOGRAPHY */
        $metadata["bibliography"] = $metadataTable;
        $biblio = $formula->getBibliography();
        if ($biblio){
            $metadata["bibliography"]["val"] = [$biblio];
        }

        /* AUTHOR OF THE RECORD */
        $metadata["author of the record"] = $metadataTable;
        $creator = $formula->getCreatedBy();
        if ($creator){
            $metadata["author of the record"]["val"] = [$creator->toPublicString()];
        }

        return $metadata;
    }
}
