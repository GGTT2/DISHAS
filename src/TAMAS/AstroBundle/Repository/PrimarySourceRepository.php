<?php

// Symfony\src\TAMAS\AstroBundle\Repository\PrimarySourceRepository.php
namespace TAMAS\AstroBundle\Repository;

use TAMAS\AstroBundle\DISHASToolbox\Table\TAMASListTableTemplate;
use TAMAS\AstroBundle\DISHASToolbox\QueryGenerator as QG;
use TAMAS\AstroBundle\DISHASToolbox\GenericTools as GT;
use TAMAS\AstroBundle\Entity as E;
use Doctrine\ORM as Doctrine;

/**
 * PrimarySourceRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class PrimarySourceRepository extends Doctrine\EntityRepository
{
    /* ____________________________________________________________________ add data ________________________________________________ */

    /**
     * prepareListForForm
     *
     * This method is used when the current entity is linked to a parent form.
     * It returns a custom DQL querybuilder (not the result!) which will be queried from the formType and findForAutofill.
     *
     * @return Doctrine\QueryBuilder
     */
    public function prepareListForForm()
    {
        return $this->createQueryBuilder('p')
            ->leftJoin('p.library', 'l')
            ->addSelect('l')
            ->orderBy('l.city, l.libraryName, p.shelfmark');
    }


    /**
     * findForAutofill
     *
     * This method is triggered in the parent entity form type by ajax. It returns the getLabeld list of object of the entity class.
     *
     * @return array : each value of the array contains an id and a title which are used in the ajax request to populate the select choice of the form such as <selec><option = "id">title</option>.
     */
    public function findForAutofill()
    {
        $entities = $this->prepareListForForm()
            ->getQuery()
            ->getResult();
        $answers = [];
        foreach ($entities as $entity) {
            $answers[] = [
                "id" => $entity->getId(),
                "title" => (string) $entity
            ];
        }
        return $answers;
    }

    /* _________________________________________________________________________ list data _________________________________________________________________________ */

    /**
     * getList
     *
     * This method is roughly equivalent to findAll(), but it lowers the number of queries to the database by selecting only the field that we are interested in displaying.
     *
     * @return array (array of primarySource objects)
     */
    public function getList()
    {
        return $this->createQueryBuilder('p')
            ->leftJoin('p.library', 'l')
            ->addSelect('l')
            ->orderBy('l.id')
            ->getQuery()
            ->getResult();
    }

    /* _________________________________________________ Get metadata _________________________________________________ */
    public function getWorks(E\PrimarySource $primarySource, $textsBySource = null, $onlyPublic = false)
    {
        if (! $textsBySource) {
            $textsBySource = $primarySource->getOriginalTexts($onlyPublic);
        }
        $result = [];
        foreach ($textsBySource as $text) {
            if ($text->getWork())
                $result[] = $text->getWork();
        }
        return array_unique($result);
    }

    public function getPublicWorks(E\PrimarySource $primarySource)
    {
        $originalTexts = $primarySource->getOriginalTexts(true);
        $works = [];
        foreach ($originalTexts as $text) {
            if ($text->getWork())
                $works[$text->getWork()->getId()] = $text->getWork();
        }
        return array_values($works);
    }

    /**
     * returns an array of language objects that are visible in the public original texts contained in the primary source
     *
     * @param E\PrimarySource $primarySource
     * @param bool $onlyPublic
     * @return array|null
     */
    public function getLanguages(E\PrimarySource $primarySource, $onlyPublic = false)
    {
        if (! $primarySource) {
            return null;
        }
        $originalTexts = $primarySource->getOriginalTexts($onlyPublic);
        $result = [];

        foreach ($originalTexts as $text) {
            if ($text->getLanguage()){
                $result[$text->getLanguage()->getId()] = $text->getLanguage();
            }
        }

        return array_values($result);
    }

    /**
     * returns an array of script objects that are visible in the public original texts contained in the primary source
     *
     * @param E\PrimarySource $primarySource
     * @param bool $onlyPublic
     * @return array|null
     */
    public function getScripts(E\PrimarySource $primarySource, $onlyPublic = false)
    {
        if (! $primarySource) {
            return null;
        }
        $originalTexts = $primarySource->getOriginalTexts($onlyPublic);
        $result = [];

        foreach ($originalTexts as $text) {
            if ($text->getScript()){
                $result[$text->getScript()->getId()] = $text->getScript();
            }
        }

        return array_values($result);
    }

    /* _________________________________________________ DataTables lists generator _________________________________________________ */
    /**
     * getFormattedList
     *
     * This method formats an array of a given entity objects in order to show it on a list
     * (a table in our twig interface). This format is not an easy task from the front-end,
     * and is much easier when it is possible to call other method from different repository (e.g. : getLabel).
     * Hence, this method lowers the number of code line / the number of query to the database
     * / make the method mutualized and so lower the amont of mistake in case of evolution of the code.
     *
     * @param array $primarySources
     *            (object)
     * @return array : formatted primary sources properties
     */
    public function getFormatedList($primarySources)
    {
        $formattedPrimarySources = [];
        if (empty($primarySources)) {
            return $formattedPrimarySources;
        }
        foreach ($primarySources as $primarySource) {
            $id = $primarySource->getId();
            $title = $primarySource->getTitle();

            $type = $primarySource->getPrimType();
            $date = "";
            $label = (string) $primarySource;
            $tpq = "";
            $taq = "";
            $created = "";
            $updated = "";
            $createdBy = [];
            $updatedBy = [];

            $scribes = [];
            $editor = '';
            $digitalIdentifier = '';
            $thatTexts = $primarySource->getOriginalTexts();
            array_map(function ($work) use (&$thatWorks) {
                $thatWorks[$work->getId()] = [
                    'id' => $work->getId(),
                    'title' => (string) $work
                ];
            }, array_filter($this->getWorks($primarySource, $thatTexts)));
            $places = $primarySource->getPlaces();
            $placesName = array_map(function ($place) {
                return $place->getPlaceName();
            }, $places);
            if ($primarySource->getCreatedBy()) {
                $createdBy = [
                    'id' => $primarySource->getCreatedBy()->getId(),
                    'username' => $primarySource->getCreatedBy()->getUserName()
                ];
            }
            if ($primarySource->getUpdatedBy()) {
                $updatedBy = [
                    'id' => $primarySource->getUpdatedBy()->getId(),
                    'username' => $primarySource->getUpdatedBy()->getUsername()
                ];
            }
            if ($primarySource->getCreated()) {
                $created = $primarySource->getCreated();
            }
            if ($primarySource->getUpdated()) {
                $updated = $primarySource->getUpdated();
            }

            $tpq = $primarySource->getTpq() ? $primarySource->getTpq() : "?";
            $taq = $primarySource->getTaq() ? $primarySource->getTaq() : "?";

            if ($primarySource->getDate()) {
                $date = $primarySource->getDate();
            }
            if ($primarySource->getPrimEditor()) {
                $editor = $primarySource->getPrimEditor();
            }
            if ($primarySource->getDigitalIdentifier()) {
                $digitalIdentifier = $primarySource->getDigitalIdentifier();
            }
            $bibRef = $primarySource->getBibRef();
            $fullTitle = [
                'id' => $id,
                'entity' => "primarySource",
                "title" => $bibRef
            ];
            if ($primarySource->getPrimType() == "ep") {
                $separator = '';
                if ($title && $editor) {
                    $separator = ', ';
                }
                $thatDate = "";
                if ($date) {
                    $thatDate = " ($date) ";
                }
                $fullTitle['title'] = $title . $separator . $editor . $thatDate . $bibRef;
            }
            $formattedPrimarySources[] = [
                'id' => $id,
                'bibRef' => $bibRef,
                'title' => $title,
                'editor' => $editor,
                'digitalIdentifier' => $digitalIdentifier,
                'label' => $label,
                'date' => $date,
                'type' => $type,
                'tpq' => $tpq,
                'taq' => $taq,
                'places' => $placesName,
                'createdBy' => $createdBy,
                'updatedBy' => $updatedBy,
                'created' => $created->format('d-m-Y'),
                'updated' => $updated->format('d-m-Y'),
                'scribes' => $scribes,
                'fullTitle' => $fullTitle
            ];
        }
        return $formattedPrimarySources;
    }

    /**
     * getObjectList
     *
     * This function generates the specs for listing a given collection of editedTexts: both the list of data
     * (pre-treated for the front library) and the spec of the table (adapted to the front library).
     *
     * @param array $primarySources : collection of all the primary sources to be listed
     * @return array : containing the list of fields and the list of data ;
     */
    public function getObjectList($primarySources)
    {
        $fieldList = [
            new TAMASListTableTemplate('id', '#'),
            new TAMASListTableTemplate('fullTitle', 'Source (Manuscript or Early printed)',['class'=>['link']]),
            new TAMASListTableTemplate('tpq', 'Term. Post Quem'),
            new TAMASListTableTemplate('taq', 'Term. Ante Quem'),
            new TAMASListTableTemplate('places', 'Place(s) of production', ['class'=>['list']]),
            new TAMASListTableTemplate('created', 'Created', [] , 'adminInfo'),
            new TAMASListTableTemplate('updated', 'Updated', [], 'adminInfo'),
            new TAMASListTableTemplate('buttons', '', [], 'editDelete')
        ];
    
        $data = $this->getFormatedList($primarySources);

        return [
            'fieldList' => $fieldList,
            'data' => $data
        ];
    }

    /**
     * Returns a field list used in the results page in the front office
     * in order to generates a DataTable of the results on a query to elasticsearch
     *
     * The name will provide the location in an array where DataTable will find the information to display
     *
     * The title correspond to the column label associated with the information
     *
     * The properties defines how the cell content will be formatted :
     * 		- class (will surround the text in a <span class="__"></span>) :
     * 			* number : in order to align the text to the right
     * 			* title-italic : to style the text of the cell in italic
     *          * uppercase : to style the text of the cell in uppercase letter
     *          * truncate : truncate all strings superior to 120 characters
     *          * capitalize : capitalize the first letter of the string
     * 		- path + id :
     * 			* Path = routing path to generate a link
     * 			* Id = location of the id in the result object
     * 		- unknown : text to display if there is no information provided in the results)
     *
     * Source defines which fields will appear in the elasticsearch response
     * corresponding to the fields that are added to the array associated with the key "source" in the query
     * (multiple fields can be added for a single column with "+")
     *
     * @return array of TAMASListTableTemplate objects
     */
    public function getPublicObjectList()
    {
        return [
            new TAMASListTableTemplate('id', '#'),
            new TAMASListTableTemplate('prim_type', 'Type'),
            new TAMASListTableTemplate('kibana_name', 'Source',
                ['path' => 'tamas_astro_viewPrimarySource', 'id' => 'id']),
            new TAMASListTableTemplate('tpq', 'Term. Post Quem', ['class'=>['number'], 'unknown'=>'?']),
            new TAMASListTableTemplate('taq', 'Term. Ante Quem', ['class'=>['number'], 'unknown'=>'?']),
            //new TAMASListTableTemplate('library', 'Library', [], '','library.kibana_name'),
            new TAMASListTableTemplate('works', ucfirst(E\Work::getInterfaceName(true)),
                ['path' => 'tamas_astro_viewWork', 'id' => 'original_texts.work.id', 'unknown'=>"No ".E\Work::getInterfaceName()." associated"],
                '', "original_texts.work.default_title+original_texts.work.id")
        ];
    }

    /* _________________________________________________ MapData generator _________________________________________________ */
    /**
     * getListPrimarySourcePlaces
     *
     * This method formats the works array in order to display the places of the works.
     * It returns a formatted list of work with its associated place
     * (title': title of the work,
     * 'long' : longitude of its place,
     * 'lat' : latitude of its place,
     * 'name': name of its place,
     * 'id': id of its place,
     * 'allName': list of the places name that share the same location
     * 'allId': list of the work that share the same location => 'id': id of the work, 'title': title of the work.)
     *
     * @param array $primarySources
     *            (array of primary sources objects)
     * @return array (formatted work with location)
     */
    public function getListPrimarySourcePlaces($primarySources)
    {
        $primarySourcePlaces = [];
        if (! $primarySources)
            return $primarySourcePlaces;

        foreach ($primarySources as $primarySource) {
            $title = (string) $primarySource;
            $places = $primarySource->getPlaces();
            $i = 0;
            foreach ($places as $place) {
                $separator = '';
                $placePerLoc = $place->getPlaceLat() . ':' . $place->getPlaceLong();
                if (isset($primarySourcePlaces[$placePerLoc])) {
                    $primarySourcePlaces[$placePerLoc]->allPlaces[] = new \TAMAS\AstroBundle\DISHASToolbox\Map\SubPlaceName($place->getPlaceName());
                    $primarySourcePlaces[$placePerLoc]->allPlaces = array_unique($primarySourcePlaces[$placePerLoc]->allPlaces);
                    $primarySourcePlaces[$placePerLoc]->allObjects[] = new \TAMAS\AstroBundle\DISHASToolbox\Map\SubObject($primarySource->getId(), $title);
                    $separator = $i;
                } elseif ($place->getPlaceLong() && $place->getPlaceLat() && $place->getPlaceName()) {
                    $data = new \TAMAS\AstroBundle\DISHASToolbox\Map\PlaceViz();
                    $data->id = $primarySource->getId();
                    $data->title = $title;
                    $data->lat = $place->getPlaceLat();
                    $data->long = $place->getPlaceLong();
                    $data->allObjects[] = new \TAMAS\AstroBundle\DISHASToolbox\Map\SubObject($primarySource->getId(), $title);
                    $data->allPlaces[] = new \TAMAS\AstroBundle\DISHASToolbox\Map\SubPlaceName($place->getPlaceName());
                    $primarySourcePlaces[$placePerLoc . $separator] = $data;
                }
                $i ++;
            }
        }
        return array_values($primarySourcePlaces);
    }

    /**
     * getDependancies
     *
     * This method is part of the process of forcing deletion of an object.
     * We need to know what are the related fields that are linked to primarySource (in order to unlink it before deleting it)
     *
     * @return array
     */
    public function getDependancies()
    {
        return [
            E\OriginalText::class => [
                'primarySource' => [
                    'unlinkMethod' => 'setPrimarySource',
                    'oneToMany' => true
                ]
            ]
        ];
    }

    /**
     * This method returns the number of pages from each work in a primary source
     *
     * @param E\PrimarySource $primSource
     * @return array|null
     */
    public function getWorkPages(E\PrimarySource $primSource)
    {
        if (! $primSource) {
            return null;
        }

        $origItemRepo = $this->getEntityManager()
            ->getRepository(E\OriginalText::class);

        $origTexts = $primSource->getOriginalTexts(true);

        $works = [];
        foreach ($origTexts as $origText){
            if ($origText->getWork()){
                array_push($works, $origText->getWork()->__toString());
            }
        }
        $works = array_unique($works);

        $worksPages = [];
        foreach ($works as $work){
            $worksPages[$work] = [];
        }

        foreach ($origTexts as $origText){
            if ($origText->getWork()){
                array_push($worksPages[$origText->getWork()->__toString()], $origItemRepo->getPagesConverted($origText));
            }
            // $workPages = [$workToStr => [["min" => pageMin, "max" => pageMax],["min" => pageMin, "max" => pageMax]]
        }

        // Ordering the original items per pageMin
        $orderedWork = [];
        foreach ($worksPages as $work => $pages){
            $orderedPages = [];
            foreach ($pages as $key => $origItem){
                $orderedPages[$key] = $origItem['min'];
            }
            array_multisort($orderedPages, SORT_ASC, $pages);
            $orderedWork[$work] = $pages;
        }

        // clustering page bounds of a set of original items on the same pages

        $workBounds = [];
        foreach ($orderedWork as $work => $pages){
            // $pages = [["min" => $pageMin, "max" => $pageMax], ["min" => $pageMin, "max" => $pageMax]]
            $bounds = [];
            $j = 0;
            $i = 0;
            foreach ($pages as $origItem){
                // $origItem = ["min" => $pageMin, "max" => $pageMax]
                if (empty($bounds)){
                    $bounds[$j] = [$pages[$i]["min"], $pages[$i]["max"]];
                } else {
                    if ($pages[$i]["min"] >= $bounds[$j][0] && $pages[$i]["min"] < $bounds[$j][1]){
                        $OImin = $pages[$i]["min"];
                        $OImax = $pages[$i]["max"];
                        $pagesMin = $bounds[$j][0];
                        $pagesMax = $bounds[$j][1];

                        $min = min($OImin, $pagesMin);
                        $max = max($OImax, $pagesMax);

                        $bounds[$j] = [$min, $max];
                    } else {
                        $j++;
                        $bounds[$j] = [$pages[$i]["min"], $pages[$i]["max"]];
                    }
                }
                $i++;
            }
            $workBounds[$work] = $bounds;
        }
        // $workBounds = [$work1 => [[$bound1min, $bound1min], [$bound2min, $bound2min]], $work2 => [[$bound1min, $bound1min]]
        $workNbPages = [];
        foreach ($workBounds as $work => $bounds){
            // bounds = [[$bound1min, $bound1min], [$bound2min, $bound2min]]
            $workNbPages[$work] = 0;
            foreach ($bounds as $bound){
                $nbPages = $bound[1] - $bound[0] + 1;
                $workNbPages[$work] = $workNbPages[$work] + $nbPages;
            }
        }

        return $workNbPages;
    }

    /**
     * This methods returns an array that can be use to generate a "box record" with the box template
     * @param E\PrimarySource $primarySource
     * @return array
     */
    function getBoxData(E\PrimarySource $primarySource){
        if ($primarySource->getPlaces()){
            $places = $primarySource->getPlaces(true);
            $placeNames = [];

            foreach ($places as $place){
                $placeNames[] = $place->toPublicString();
            }

            if (count($placeNames) == 0){
                $placeName = "<span class='noInfo'>Unknown place</span>";
            } elseif (count($placeNames) == 1){
                $placeName = $placeNames[0];
            } elseif (count($placeNames) == 2){
                $placeName =
                    explode(", ", $placeNames[0])[count(explode(", ", $placeNames[0]))-1].
                    " & ".
                    explode(", ", $placeNames[1])[count(explode(", ", $placeNames[1]))-1];
            } else {
                $placeName = count($placeNames)."<i> creation places</i>";
            }
        } else {
            $placeName = "<span class='noInfo'>Unknown place</span>";
        }

        $library = "<span class='noInfo'>Unknown curation place</span>";
        if ($primarySource->getLibrary()){
            $library = $primarySource->getLibrary()->getLibraryName();
        }

        return [
            "id" => $primarySource->getId(),
            "title" => $primarySource->__toString(),
            "from" => $primarySource->getTpq(true) ? $primarySource->getTpq(true) : "?",
            "to" => $primarySource->getTaq(true) ? $primarySource->getTaq(true) : "?",
            "latlong" => "0,0",
            "place" => $placeName,
            "library" => $library
        ];
    }

    /**
     * This method returns an associative array that can be use to generate "boxes"
     * when clicking on the element of the bar chart
     * This method is used for the record page of a primary source
     *
     * @param E\PrimarySource $primarySource
     * @return array
     */
    public function getBoxesData(E\PrimarySource $primarySource)
    {
        if (! $primarySource) {
            return null;
        }
        $boxesData = [];

        $workRepo = $this->getEntityManager()->getRepository(E\Work::class);
        $origItemRepo = $this->getEntityManager()->getRepository(E\OriginalText::class);
        $astroObjectRepo = $this->getEntityManager()->getRepository(E\AstronomicalObject::class);

        if ($primarySource->getOriginalTexts(true)){
            $origItems = $primarySource->getOriginalTexts(true);
            foreach ($origItems as $item){
                $boxesData["oi".$item->getId()] = $origItemRepo->getBoxData($item);
                $astroObject = $item->getTableType()->getAstronomicalObject();
                if (! array_key_exists("tt".$astroObject->getId(), $boxesData)){
                    $boxesData["ao".$astroObject->getId()] = $astroObjectRepo->getBoxData($astroObject);
                }
            }
        }

        if ($this->getPublicWorks($primarySource)){
            $works = $this->getWorks($primarySource);
            foreach ($works as $work){
                $boxesData["wo".$work->getId()] = $workRepo->getBoxData($work);
            }
        }

        return $boxesData;
    }

    /**
     * This methods returns an array of all the ids of the original items in a primary source sorted by work
     *
     * $ids = [workId1 => [workId1, oiId1, oiId2], workId2 => [workId2, oiId3, oiId4, oiId5]];
     *
     * This method is used in the primary source record page to generate the record boxes
     * of a work and its original items in a primary source when clicking on column label
     *
     * @param E\PrimarySource $primSource
     * @return array
     */
    function getIdsFromWorks(E\PrimarySource $primSource){
        if (! $primSource) {
            return null;
        }

        $ids = [];
        if ($primSource->getOriginalTexts(true)){
            $originalTexts = $primSource->getOriginalTexts(true);
            foreach ($originalTexts as $text){
                if ($text->getWork()){
                    if (! array_key_exists($text->getWork()->getId(), $ids)){
                        $ids[$text->getWork()->getId()] = ["wo".$text->getWork()->getId()];
                    }
                    $ids[$text->getWork()->getId()][] = "oi".$text->getId();
                }
            }
        }

        return $ids;
    }

    /**
     *
     * This methods returns an array of all the ids of the original items from a primary source sorted by astronomical object
     *
     * $ids = [astroObjectId1 => [ttId1, oiId1, oiId2], astroObjectId2 => [ttId2, oiId3, oiId4, oiId5]];
     *
     * This method is used in the primary source record page to generate the record boxes
     * of an astronomical object and its original items in a primary source when clicking on legend item
     *
     * @param E\PrimarySource $primarySource
     * @return array|null
     */
    function getIdsFromAstroObject(E\PrimarySource $primarySource){
        if (! $primarySource) {
            return null;
        }

        $ids = [];
        if ($primarySource->getOriginalTexts(true)){
            $originalTexts = $primarySource->getOriginalTexts(true);
            foreach ($originalTexts as $text){
                if ($text->getTableType()){
                    if (! array_key_exists($text->getTableType()->getAstronomicalObject()->getId(), $ids)){
                        $ids[$text->getTableType()->getAstronomicalObject()->getId()] = ["ao".$text->getTableType()->getAstronomicalObject()->getId()];
                    }
                    $ids[$text->getTableType()->getAstronomicalObject()->getId()][] = "oi".$text->getId();
                }
            }
        }
        return $ids;
    }

    /**
     * This method returns "folios" if the primary source is mainly composed of original item in folio
     * or "pages" otherwise
     * @param E\PrimarySource $primarySource
     * @return string
     */
    function foliosOrPages(E\PrimarySource $primarySource){
        $originalTexts = $primarySource->getOriginalTexts(true);
        $count = 0;
        foreach ($originalTexts as $oi){
            $count += $oi->getIsFolio() ? 1 : -1;
        }

        return $count >= 0 ? "folios" : "pages";
    }

    /**
     * This method returns an associative array used to generate the bar chart on the primary source record page
     *
     * @param E\PrimarySource $primarySource
     * @return array|null
     */
    function getBarData(E\PrimarySource $primarySource)
    {
        if (! $primarySource) {
            return null;
        }

        $originalTexts = $primarySource->getOriginalTexts(true);
        usort($originalTexts, array('TAMAS\AstroBundle\DISHASToolbox\GenericTools', 'compareAstroObject'));
        $worksIds = $this->getIdsFromWorks($primarySource);
        /**
         * $bardata = [
         *      [
         *          "work" => "title \n author \n date", // column label
         *          "Work-ids" => [woId, oiId, oiId], // ids of the work and all the original items that are in it (to generate boxes)
         *          "origItemTooltip" => "title \n astronomical object \n page bounds \n date", // tooltip appearing on hover on column element
         *          "OI-id" => [oiId], // id from the current original item
         *          "color" => "colorOfTheAstronomicalObject" // color used on the column element
         *          "from" => pageMin,
         *           $i => pageMax // to determine the height of a column element
         *      ],
         *      [...]
         *  ]
         */
        $barData = [];
        $i = 1;
        foreach ($originalTexts as $oi){
            $oiData = [];
            if ($oi->getWork()){
                $workName = GT::shortenString($oi->getWork()->toPublicTitle(), 45);
                $workDate = "\n".$oi->getWork()->getTpaq();
                $workActors = $oi->getWork()->getHistoricalActors() ? $oi->getWork()->getHistoricalActors() : [];
                $actorNames = "";
                foreach ($workActors as $index => $actor){
                    if ($index < 2){
                        $actorNames = $actorNames."\n".$actor->getActorName();
                    } elseif ($index == 2){
                        $actorNames = $actorNames."\n...";
                    }
                }
                $workIds = $worksIds[$oi->getWork()->getId()];
            } else {
                $workName = "Unknown ".E\Work::getInterfaceName()."\n";
                $workDate = "";
                $actorNames = "Unknown creator";
                $workIds = [];
            }

            $oiData["work"] = "[bold]".strip_tags($workName)."[/]".$actorNames.$workDate;
            $oiData["Work-ids"] = $workIds;
            $oiData["origItemTooltip"] = "[bold]".strip_tags($oi->toPublicTitle())."[/]".
                "\nSubject : ".ucfirst($oi->getTableType()->getAstronomicalObject()->getObjectName()).
                "\nPages : ".GT::getTpaq($oi->getPageMin(), $oi->getPageMax()).
                "\n".$oi->getTpaq();
            $oiData["from"] = $oi->getConvertedPageMin();
            $oiData[$i] = $oi->getConvertedPageMax();
            $oiData["OI-id"] = ["oi".$oi->getId()];
            $oiData["color"] = $oi->getTableType() ? $oi->getTableType()->getAstronomicalObject()->getColor() : "rgb(176,164,170)";
            $oiData["folio"] = $oi->getIsFolio();
            $barData[] = $oiData;
            $i ++;
        }

        return $barData;
    }

    /**
     * Returns an dataset that can be used to generate a DISHAS bas chart
     * @param E\PrimarySource $primSource
     * @return array
     */
    public function getBarChartData(E\PrimarySource $primSource)
    {
        return [
            "chart" => [
                ["type" => "Bar",
                    "data" => $this->getBarData($primSource)]
            ],
            "box" => $this->getBoxesData($primSource),
            "legend" => $this->getIdsFromAstroObject($primSource)
        ];
    }

    /**
     * getMetadataTable
     *
     * this methods returns an array containing all the metadata of a primary source necessary to constitute
     * the sidebar on the visualization page of a primary source record.
     *
     * $metadata = ["title" => $title,
     *             ("subtitle" => $titleOriginalChar),
     *              "shelfmark" => [$shelfmark],
     *              "library" => [$library],
     *             ("editor" => [$editor],
     *              "editionDate" => [$editionDate]),
     *              "place" => [$place],
     *              "date" => [$tpaq],
     *              "scribe" => [$scribe],
     *              "script" => [$script],
     *              "language" => [$language],
     *              "user" => [$user]]
     *
     * @param E\PrimarySource $primSource
     * @return array
     * @throws \Exception
     */
    public function getMetadataTable(E\PrimarySource $primSource)
    {
        if (! $primSource) {
            return null;
        }

        $metadata = [];
        $metadata["entity"] = "primary_source";

        // radius in kilometer in which the geographical queries are made
        $distance = "100";
        $primSourceName = E\PrimarySource::getInterfaceName(true);

        /* UPPER PART OF THE SIDEBAR */
        $title = $primSource->toPublicTitle();
        $metadata["title"] = $title;
        if ($primSource->getPrimTitleOriginalChar()){
            $metadata["subtitle"] = strval($primSource->getPrimTitleOriginalChar());
        }

        /* RELATED EDITIONS */
        $metadata["edition"] = "original_texts.edited_texts.kibana_name+original_texts.edited_texts.kibana_id";
        /*$editionNames = E\EditedText::getInterfaceName(true);
        $workName = E\Work::getInterfaceName();
        $filter = QG::newMultiMatchFilter(["original_texts.primary_source.id","related_editions.original_texts.primary_source.id"], $primSource->getId());
        $metadata["edition"] = [
            "json" => QG::setFilters([$filter]),
            "hover" => "Find all the $editionNames of this $workName",
            "title" => "All the $editionNames of the $title"];*/

        $metadataTable = ["val" => [], "search" => ["json" => [], "hover" => "", "title" => []]];

        /* SHELFMARK */
        $metadata["shelfmark"] = $metadataTable;
        $shelfmark=$primSource->getShelfmark()?strval($primSource->getShelfmark()):"";
        if ($primSource->getDigitalIdentifier()){
            $digId = strval($primSource->getDigitalIdentifier());
            $truncDigId = GT::truncate($digId);
            $shelfmark = $shelfmark . "<br/>(<a href='https://www.google.com/search?q=\"".$digId."\"' title='".$digId."'>" . $truncDigId . "</a>)";
        }
        $metadata["shelfmark"]["val"][] = $shelfmark;

        /* LIBRARY */
        $metadata["library"] = $metadataTable;
        $metadata["library"]["search"]["hover"] = "Find all $primSourceName kept in the same library";

        if ($primSource->getLibrary()){
            $library = $primSource->getLibrary();
            $libName = "";
            if (! empty($library)){
                $libName = $library->toPublicString();
            }
            $metadata["library"]["val"][] = $libName;
            $metadata["library"]["search"]["title"][] = "All $primSourceName kept in " . $library->getLibraryName();

            $filter = QG::newMatchFilter("library.kibana_id.keyword", "Library".$library->getId());
            $query = QG::setFilters([$filter]);
            $metadata["library"]["search"]["json"][] = $query;
        }

        /* EDITOR, DATE OF EDITION */
        if ($primSource->getPrimType() == "ep"){
            $metadata["editor"] = $metadataTable;
            if ($primSource->getPrimEditor()){
                $metadata["editor"]["val"][] = strval($primSource->getPrimEditor());
                /*$metadata["editor"]["search"]["hover"] = "Find all $primSourceName edited by the same editor";
                $metadata["editor"]["search"]["title"][] = "All $primSourceName edited by " . strval($primSource->getPrimEditor());

                $filter = QG::newMatchFilter("prim_editor", strval($primSource->getPrimEditor()));
                $query = QG::setFilters([$filter]);
                $metadata["editor"]["search"]["json"][] = $query;*/
            }

            if ($primSource->getDate()){
                $metadata["date of edition"] = $metadataTable;
                $metadata["date of edition"]["val"][] = strval($primSource->getDate());
                $metadata["date of edition"]["search"]["hover"] = "Find all $primSourceName edited less than 25 years apart";
                $metadata["date of edition"]["search"]["title"][] = "All $primSourceName edited less than 25 years apart from " . strval($primSource->getDate());

                $filter = QG::newRangeFilter("date", $primSource->getDate(), "25");
                $query = QG::setFilters([$filter]);
                $metadata["date of edition"]["search"]["json"][] = $query;
            }
        }

        /* PLACE (placeName/id) */
        $places = $primSource->getPlaces(true);
        $nPlaces = "";
        if ($places){
            $nPlaces = count($places) <= 1 ? "" : "s";
        }


        $fieldname = "writing place$nPlaces";
        if ($primSource->getPrimType() == "ep"){
            $fieldname = "place$nPlaces of edition";
        }

        $values = []; // Ex : Paris, France
        $queries = [];
        $titles = [];
        $hover = "Find all $primSourceName originated within a $distance km radius";

        if (! $places){ // if there is no places associated with the primary source
            $values[] = "";
        } else {
            foreach ($places as $place){
                $values[] = $place->toPublicString();
                $titles[] = "All $primSourceName created in the area of ".$place->toPublicString();

                $filter = QG::newPlacesFilter($place->getLat(),$place->getLong());
                $query = QG::setFilters([$filter]);
                $queries[] = $query;
            }
        }
        $metadata[$fieldname] = GT::setMetadata($hover,$values,$queries,$titles);

        /* DATE (tpq + taq) */
        $tpq = $primSource->getTpq(true) ? $primSource->getTpq(true) : "?";
        $taq = $primSource->getTaq(true) ? $primSource->getTaq(true) : "?";

        $values = [];
        $queries = [];
        $titles = [];
        $hover = "Find all $primSourceName created at the same period";

        $fieldname = "timeframe of creation";
        if ($tpq == $taq){
            $fieldname = $primSource->getPrimType() == "ep"?"add-ons redaction":"date of creation";
            $hover = "Find all $primSourceName created less than 25 years apart";
        }

        if ($tpq != "?" || $taq != "?"){ // if tpq or taq are filled in
            list($filterTpq, $filterTaq) = QG::newTimerangeFilter($tpq, $taq);
            $query = QG::setFilters([$filterTpq, $filterTaq]);
            $queries[] = $query;
            $titles[] = "All $primSourceName created around ".$primSource->getTpaq();
        }

        if (!($tpq == $taq && intval($tpq) == intval($primSource->getDate()))){
            // if all the dates of the original items are the same as the edition date
            // do nothing in order to not display this category in the sidebar of metadata
            $values[] = $primSource->getTpaq(true);
        }

        $metadata[$fieldname] = GT::setMetadata($hover,$values,$queries,$titles);

        /* SCRIBAL AGENT (actorName/id + tpq + taq + viafIdentifier) */
        $scribes = $primSource->getActors(true);
        $nScribes = count($scribes) <= 1?"":"s";

        $fieldname = "scribal$nScribes agent";
        $values = [];
        $queries = [];
        $titles = [];
        $hover = "Find all $primSourceName copied by the same historical actor";

        foreach ($scribes as $scribe){
            if (! empty($scribe)){
                $values[] = $scribe->toPublicString();
                $titles[] = "All $primSourceName copied by ".$scribe->toPublicTitle();

                $filter = QG::newMatchFilter("original_texts.historical_actor.kibana_id.keyword", "HistoricalActor".$scribe->getId());
                $query = QG::setFilters([$filter]);
                $queries[] = $query;
            }
        }

        $metadata[$fieldname] = GT::setMetadata($hover,$values,$queries,$titles);

        /* SCRIPTS (scriptName + iso15924) */
        $scripts = $this->getScripts($primSource,true);
        $nScripts = count($scripts) <= 1?"":"s";

        $fieldname = "script$nScripts";
        $values = [];
        $queries = [];
        $titles = [];
        $hover = "Find all $primSourceName written in the same script";

        foreach ($scripts as $script){
            if (! empty($script)){
                $values[] = $script->toPublicString();
                $titles[] = "All $primSourceName written in ".$script->getScriptName();

                $filter = QG::newMatchFilter("original_texts.script.keyword", $script->__toString());
                $query = QG::setFilters([$filter]);
                $queries[] = $query;
            }
        }

        $metadata[$fieldname] = GT::setMetadata($hover,$values,$queries,$titles);

        /* LANGUAGES (languageName + iso6392) */
        $languages = $this->getLanguages($primSource,true);
        $nLanguages = count($languages) <= 1?"":"s";

        $fieldname = "language$nLanguages";
        $values = [];
        $queries = [];
        $titles = [];
        $hover = "Find all $primSourceName written in the same language";

        foreach ($languages as $language){
            if (!empty($language)){
                $values[] = $language->toPublicString();
                $titles[] = "All $primSourceName written in ".$language->getLanguageName();

                $filter = QG::newMatchFilter("original_texts.language.keyword", $language->__toString());
                $query = QG::setFilters([$filter]);
                $queries[] = $query;
            }
        }

        $metadata[$fieldname] = GT::setMetadata($hover,$values,$queries,$titles);

        /* USER (username/id) */
        $metadata["author of the record"] = $metadataTable;
        $user = $primSource->getCreatedBy();
        $username = $user->toPublicString();
        $metadata["author of the record"]["val"][] = $username;

        /* DATA VISUALIZATION (percentage pages from each work in the current primary source */
        $datavisTable = ["data" => "", "title" => ""];

        $origTexts = $primSource->getOriginalTexts(true);
        $works = [];
        foreach ($origTexts as $origText){
            if ($origText->getWork()){
                array_push($works, $origText->getWork()->__toString());
            }
        }
        $uniqueWorks = array_unique($works);

        if (count($uniqueWorks) > 1){
            $workName = E\Work::getInterfaceName();
            $metadata["visualization"] = $datavisTable ;
            $metadata["visualization"]["title"] = "Percentage of pages from each $workName present in the primary source";
            $data = ["category" => "", "value" => ""];
            $allData = [];

            $workPages = $this->getWorkPages($primSource);

            foreach ($uniqueWorks as $uniqueWork){
                $data['category'] = $uniqueWork;
                $data['value'] = $workPages[$uniqueWork];
                array_push($allData, $data);
            }
            $metadata["visualization"]["data"] = json_encode($allData);
        }
        return $metadata;
    }


    /* _____________________________________________________________________ Draft_________________________________________________________ */

/**
 * This function is used for autocompletion purpose.
 * It gives an array of answers that start with the entered value in the form.
 *
 * @param string $term
 * @return array
 */
    /*
     * public function findForAutocomplete($term) {
     * $queryResult = $this->createQueryBuilder('ps')
     * ->select('ps.shelfmark', 'ps.id')
     * ->leftJoin('ps.library', 'l') // shows result even when there is not registered library
     * ->addSelect('l.libraryName')
     * ->where('ps.shelfmark LIKE :term')
     * ->setParameter('term', $term . '%')
     * ->orderBy('ps.shelfmark')
     * ->getQuery()
     * ->getResult();
     * $arrayResult = [];
     * foreach ($queryResult as $result) {
     * $arrayResult[] = ['value' => $result['shelfmark'], 'label' => $result['shelfmark'] . ' (' . $result['libraryName'] . ')', 'id' => $result['id'], 'form_field' => 'primarySource'];
     * }
     * return $arrayResult;
     * }
     */

}
