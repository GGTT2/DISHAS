<?php

// Symfony\src\TAMAS\AstroBundle\Repository\OriginalTextRepository.php
namespace TAMAS\AstroBundle\Repository;


use TAMAS\AstroBundle\DISHASToolbox\Table\TAMASListTableTemplate;
use TAMAS\AstroBundle\DISHASToolbox\QueryGenerator as QG;
use TAMAS\AstroBundle\DISHASToolbox\GenericTools as GT;
use TAMAS\AstroBundle\Entity as E;
use Doctrine\ORM as Doctrine;

/**
 * OriginalTextRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class OriginalTextRepository extends Doctrine\EntityRepository
{

    private $parameters = array();

    private $count = 0;


    /* ___________________________________________________________________ add data ________________________________________________________ */

    /**
     * prepareListForForm
     *
     * This method is used when the current entity is linked to a parent form.
     * It returns a custom DQL query builder (not the result!) which will be queried
     * from the formType and findForAutofill.
     *
     * @param null $option
     * @return Doctrine\QueryBuilder
     */
    public function prepareListForForm($option = null)
    {
        $query = $this->createQueryBuilder('o')
            ->leftJoin('o.tableType', 'tt')
            ->addSelect('tt')
            ->leftJoin('o.work', 'w')
            ->addSelect('w')
            ->leftJoin('o.primarySource', 'p')
            ->addSelect('p')
            ->leftJoin('p.library', 'l')
            ->addSelect('l');
        if ($option) {
            $query->where('tt.id = :option')->setParameter('option', $option);
        }
        $query->orderBy('o.originalTextTitle', 'ASC');
        return $query;
    }


    /**
     * findForAutofill
     *
     * This method is used for listing in a drop-down select menue the parameter sets documented in the database.
     *
     * @return array : each value of the array contains an id and a title which are used in the ajax request to populate the select choice of the form such as <selec><option = "id">title</option>.
     */
    public function findForAutofill($option = null)
    {
        $queryResult = $this->prepareListForForm($option)
            ->getQuery()
            ->getResult();
        $arrayResult = [];
        foreach ($queryResult as $originalText) {
            $result = [
                'id' => $originalText->getId(),
                'title' => (string) $originalText,
                'tableTypeId' => $originalText->getTableType()->getId()
            ];
            if (! $originalText->getPublic()) {
                $result += [
                    'draft' => 'draft'
                ];
            }
            $arrayResult[] = $result;
        }
        return $arrayResult;
    }

    /* ________________________________________________________ list data ________________________________________________ */

    /**
     * getList
     *
     * This method is roughly equivalent to findAll(), but it lowers the number of queries to the database by selecting only the field that we are interested in displaying.
     *
     * @return array of object originalTexts
     */
    public function getList()
    {
        return $this->createQueryBuilder('o')
            ->leftJoin('o.place', 'p')
            ->addSelect('p')
            ->leftJoin('o.historicalActor', 'h')
            ->addSelect('h')
            ->leftJoin('o.work', 'w')
            ->addSelect('w')
            ->leftJoin('w.historicalActors', 'hi')
            ->addSelect('hi')
            ->leftJoin('o.language', 'l')
            ->addSelect('l')
            ->leftJoin('o.script', 's')
            ->addSelect('s')
            ->leftJoin('o.primarySource', 'ps')
            ->addSelect('ps')
            ->leftJoin('ps.library', 'lib')
            ->addSelect('lib')
            ->orderBy('o.originalTextTitle, o.id')
            ->getQuery()
            ->getResult();
    }

    /**
     * getFormatedList
     *
     * This method formats an array of originalTexts objects in order to show on a list.
     *
     * @param array $originalTexts
     *            (objects)
     * @return array : formatted originalTexts properties
     */
    public function getFormatedList($originalTexts)
    {
        $formattedOriginalTexts = [];
        if (empty($originalTexts)) {
            return $formattedOriginalTexts;
        }
        foreach ($originalTexts as $originalText) {
            $id = $originalText->getId();
            $createdBy = [];
            $originalTitle = [
                'entity' => 'originalText',
                'id' => $id,
                'title' => $originalText->getTitle(),
                'public' => $originalText->getPublic()
            ];
            $tpq = ($originalText->getTpq() ? $originalText->getTpq() : '');
            $taq = ($originalText->getTaq() ? $originalText->getTaq() : '');
            $script = "";
            $language = "";
            $historicalActor = "";
            $workActors = [];
            $work = [];
            $place = "";
            $primSource = [];
            $public = $originalText->getPublic();
            $created = ($originalText->getCreated() ? $originalText->getCreated() : '');
            $updated = ($originalText->getUpdated() ? $originalText->getUpdated() : '');
            $updatedBy = [];
            if ($originalText->getCreatedBy()) {
                $createdBy = [
                    'id' => $originalText->getCreatedBy()->getId(),
                    'username' => $originalText->getCreatedBy()->getUserName()
                ];
            }
            if ($originalText->getUpdatedBy()) {
                $updatedBy = [
                    'id' => $originalText->getUpdatedBy()->getId(),
                    'username' => $originalText->getUpdatedBy()->getUsername()
                ];
            }
            if ($originalText->getScript() && $originalText->getScript()->getScriptName())
                $script = $originalText->getScript()->getScriptName();
            if ($originalText->getLanguage() && $originalText->getLanguage()->getLanguageName())
                $language = $originalText->getLanguage()->getLanguageName();
            if ($originalText->getHistoricalActor()) {
                $historicalActor = (string) $originalText->getHistoricalActor();
            }

            if ($originalText->getWork()) {
                $work['id'] = $originalText->getWork()->getId();
                $work['entity'] = "work";
                $work['title'] = (string) $originalText->getWork();

                foreach ($originalText->getWork()->getHistoricalActors() as $workActor) {
                    $workActors[] = (string) $workActor;
                }
            }
            if ($originalText->getPlace() && $originalText->getPlace()->getPlaceName()) {
                $place = $originalText->getPlace()->getPlaceName();
            }
            if ($originalText->getPrimarySource()) {
                $title = (string) $originalText->getPrimarySource();
                $primSource = [
                    'id' => $originalText->getPrimarySource()->getId(),
                    'title' => $title,
                    'entity' => "primarySource"
                ];
            }
            $formattedOriginalTexts[] = [
                'id' => $id,
                'title' => $originalTitle,
                'tpq' => $tpq,
                'taq' => $taq,
                'historicalActor' => $historicalActor,
                'place' => $place,
                'language' => $language,
                'script' => $script,
                'work' => $work,
                'workActors' => $workActors,
                'primarySource' => $primSource,
                'createdBy' => $createdBy,
                'public' => $public,
                'created' => $created->format('d-m-Y'),
                'updated' => $updated->format('d-m-Y'),
                'updatedBy' => $updatedBy
            ];
        }
        return $formattedOriginalTexts;
    }

    /**
     * getObjectList
     *
     * This function generates the specs for listing a given collection of editedTexts: both the list of data (pre-treated for the front library) and the spec of the table (adapted to the front library).
     *
     * @param array $originalTexts : collection of all the original texts to be listed
     * @return array : containing the list of fields and the list of data ;
     */
    public function getObjectList($originalTexts)
    {
        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);
        $workName = ucfirst($defRepo->getInterfaceName("work"));
        $fieldList = [
            new    TAMASListTableTemplate('id', '#'),
            new    TAMASListTableTemplate('title', 'Title', ['class'=>['link']]),
            new    TAMASListTableTemplate('tpq', 'Term. Post Quem'),
            new    TAMASListTableTemplate('taq', 'Term. Ante Quem'),
            new    TAMASListTableTemplate('historicalActor', 'Scribal agent'),
            new    TAMASListTableTemplate('place', 'Place of conception'),
            new    TAMASListTableTemplate('language', 'Language'),
            new    TAMASListTableTemplate('script', 'Script'),
            new    TAMASListTableTemplate('work', "$workName", ['class'=>['link']]),
            new    TAMASListTableTemplate('workActors', "$workName creator(s)"),
            new    TAMASListTableTemplate('primarySource', ucfirst($defRepo->getInterfaceName("primarySource")), ['class'=> ['link']]),
            new    TAMASListTableTemplate('created', 'Created', [], 'adminInfo'),
            new    TAMASListTableTemplate('updated', 'Updated', [], 'adminInfo'),
            new    TAMASListTableTemplate('buttons', '', [], 'editDelete')
        ];

        $data = $this->getFormatedList($originalTexts);

        return [
            'fieldList' => $fieldList,
            'data' => $data
        ];
    }

    /**
     * Returns a field list used in the results page in the front office
     * in order to generates a DataTable of the results on a query to elasticsearch
     *
     * The name provides the location in an array where DataTable will find the information to display
     *
     * The title corresponds to the column label associated with the information
     *
     * The properties defines how the cell content will be formatted :
     * 		- class (will surround the text in a <span class="__"></span>) :
     * 			* number : in order to align the text to the right
     * 			* title-italic : to style the text of the cell in italic
     *          * uppercase : to style the text of the cell in uppercase letter
     *          * truncate : truncate all strings superior to 120 characters
     *          * capitalize : capitalize the first letter of the string
     * 		- path + id :
     * 			* path : routing path to generate a link
     * 			* id : location of the id in the result object
     * 		- unknown : text to display if there is no information provided in the results)
     *
     * Source defines which fields will appear in the elasticsearch response
     * corresponding to the fields that are added to the array associated with the key "source" in the query
     * (multiple fields can be added for a single column with "+")
     *
     * @return array of TAMASListTableTemplate objects
     */
    public function getPublicObjectList()
    {
        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);
        return [
            new TAMASListTableTemplate('id', '#'),
            new TAMASListTableTemplate('original_text_title', 'Title',
                ['class'=>['title-italic'],'path' => 'tamas_astro_viewOriginalText', 'id' => 'id']),
            new TAMASListTableTemplate('tpq', 'Term. Post Quem', ['class'=>['number'], 'unknown'=>'?']),
            new TAMASListTableTemplate('taq', 'Term. Ante Quem', ['class'=>['number'], 'unknown'=>'?']),
            new TAMASListTableTemplate('primary_source', ucfirst($defRepo->getInterfaceName("primarySource")),
                ['path' => 'tamas_astro_viewPrimarySource', 'id' => 'primary_source.id'],
                '', 'primary_source.kibana_name+primary_source.id'),
            new TAMASListTableTemplate('work', ucfirst($defRepo->getInterfaceName("work")),
                ['class'=>['title-italic'],'path' => 'tamas_astro_viewWork', 'id' => 'work.id'],
                '', 'work.kibana_name+work.id')
        ];
    }


    /**
     * This method generates a list template used to create the Historical navigation page
     * composed with a map of all the original items associated with a place
     *
     * Name : provides the name of the key where the information for each field is going to be contained
     * Title : column label (not really useful for the data used by the map visualisation
     * Properties : defines how the data will be formatted
     * Source : fields that need to appear in the query response
     *
     * @return array
     */
    public function getPublicObjectListForMap()
    {
        return [
            new TAMASListTableTemplate('id','#',[],'','primary_source.id'),
            new TAMASListTableTemplate('title', 'Source',
                ['unknown'=>'No title provided'],
                '', 'primary_source.default_title+primary_source.tpq+primary_source.taq'),
            new TAMASListTableTemplate('from', 'From', ['unknown'=>'?'], '', 'tpq'),
            new TAMASListTableTemplate('to', 'To', ['unknown'=>'?'], '', 'taq'),
            new TAMASListTableTemplate('place', 'Place of creation',
                ['unknown'=>'Unknown place'],'','place.kibana_name'),
            new TAMASListTableTemplate('library', 'Place of curation',
                ['unknown'=>'Unknown library'],'',"primary_source.library.kibana_name"),
            new TAMASListTableTemplate('latlong', 'Latitude & longitude', ['unknown'=> 0],
                '','place.location', false)
        ];
    }

    /* _____________________________________________ other tools ___________________________________________________________ */

    // These methods are using originalText as a go-between when they are not directly linked to their attribute.

    /**
     * getListOriginalTextPlaces
     *
     * This method formats the originalTexts in order to display the places of the originalTexts.
     *
     * @param array $originalTexts
     *            : unformatted array of originalText objects
     * @return array : formatted originalTexts
     */
    public function getListOriginalTextPlaces($originalTexts)
    {
        $originalPlaces = [];
        foreach ($originalTexts as $text) {
            $title = $text->getTitle();
            if ($text->getPlace() && $text->getPlace()->getPlaceLong() && $text->getPlace()->getPlaceLat() && $text->getPlace()->getPlaceName()) {
                $data = new \TAMAS\AstroBundle\DISHASToolbox\Map\PlaceViz();
                $data->id = $text->getId();
                $data->title = $title;
                $data->lat = $text->getPlace()->getPlaceLat();
                $data->long = $text->getPlace()->getPlaceLong();
                $data->allPlaces[] = new \TAMAS\AstroBundle\DISHASToolbox\Map\SubPlaceName($text->getPlace()->getPlaceName());
                $originalPlaces[] = $data;
            }
        }
        foreach ($originalPlaces as &$originalPlace) {
            foreach ($originalTexts as $text) {
                if ($text->getPlace() && $text->getPlace()->getPlaceLong() && $text->getPlace()->getPlaceLat() && $text->getPlace()->getPlaceName()) {
                    $title = $text->getTitle();
                    if ($originalPlace->long == $text->getPlace()->getPlaceLong() && $originalPlace->lat == $text->getPlace()->getPlaceLat()) {
                        $originalPlace->allPlaces[] = new \TAMAS\AstroBundle\DISHASToolbox\Map\SubPlaceName($text->getPlace()->getPlaceName());
                        $originalPlace->allObjects[] = new \TAMAS\AstroBundle\DISHASToolbox\Map\SubObject($text->getId(), $title);
                    }
                }
            }
            $originalPlace->allPlaces = array_unique($originalPlace->allPlaces);
        }
        unset($originalPlace);

        return $originalPlaces;
    }

    /**
     * getDependencies
     *
     * This method is part of the process of forcing deletion of an object.
     * We need to know what are the related fields that are linked to originalText (in order to unlink it before deleting it)
     *
     * @return array
     */
    public function getDependancies()
    {
        return [
            E\EditedText::class => [
                'originalTexts' => [
                    'unlinkMethod' => 'removeOriginalText',
                    'oneToMany' => false
                ]
            ]
        ];
    }

    /**
     * getPagesConverted
     *
     * This method returns the value of pageMin and pageMax converted in pages instead of folios;
     *
     * Example : ["min" => $valueOfPageMin, "max" => $valueOfPageMax]
     *
     * @param E\OriginalText $originalText
     * @return array
     */
    public function getPagesConverted(E\OriginalText $originalText)
    {
        if (! $originalText)
            return [];

        return [
            "min" => $originalText->getConvertedPageMin(),
            "max" => $originalText->getConvertedPageMax()
        ];
    }

    /**
     * This method allows to add a record of original item to the array of map data
     * that can be used to generate a chronological map
     *
     * @param E\OriginalText $item
     * @param array $mapData
     * @param array $entities : array detailing which entities will appear on the map ["originalText" => [], "work" => []]
     * @return mixed
     */
    public function getPlaceData(E\OriginalText $item, $mapData, $entities){
        $oiId = "oi".$item->getId();

        if ($item->getPlace()){
            $lat = $item->getPlace()->getLat() ? $item->getPlace()->getLat() : 0;
            $long = $item->getPlace()->getLong() ? $item->getPlace()->getLong() : 0;

            if (! isset($mapData["$lat,$long"])){
                $mapData["$lat,$long"] = [
                    "lat" => $lat,
                    "long" => $long,
                    "place" => $item->getPlace()->getPlaceName(),
                    "ids" => $entities
                ];
            }
            if (! in_array($oiId, $mapData["$lat,$long"]["ids"]["originalText"])){
                $mapData["$lat,$long"]["ids"]["originalText"][] = $oiId;
            }
        } else {
            if (!isset($mapData["0,0"])){
                $mapData["0,0"] = [
                    "lat" => 0,
                    "long" => 0,
                    "place" => "<span class='noInfo'>Unknown place</span>",
                    "ids" => $entities
                ];
            }

            if (! in_array($oiId, $mapData["0,0"]["ids"]["originalText"])){
                $mapData["0,0"]["ids"]["originalText"][] = $oiId;
            }
        }

        return $mapData;
    }

    /**
     * This method allows to add a record of primary source (associated with an original item) to the array of map data
     * that can be used to generate a chronological map
     *
     * @param E\OriginalText $item
     * @param array $mapData
     * @param array $entities : array detailing which entities will appear on the map ["primarySource" => [], "work" => []]
     * @return mixed
     */
    public function getPrimarySourcePlaceData(E\OriginalText $item, $mapData, $entities){
        if (! $item->getPrimarySource()){
            return $mapData;
        }
        $psId = "ps".$item->getPrimarySource()->getId();

        if ($item->getPlace()){
            $lat = $item->getPlace()->getLat() ? $item->getPlace()->getLat() : 0;
            $long = $item->getPlace()->getLong() ? $item->getPlace()->getLong() : 0;

            if (! isset($mapData["$lat,$long"])){
                $mapData["$lat,$long"] = [
                    "lat" => $lat,
                    "long" => $long,
                    "place" => $item->getPlace()->getPlaceName(),
                    "ids" => $entities
                ];
            }

            if (! in_array($psId, $mapData["$lat,$long"]["ids"]["primarySource"])){
                $mapData["$lat,$long"]["ids"]["primarySource"][] = $psId;
            }
        } else {
            if (!isset($mapData["0,0"])){
                $mapData["0,0"] = [
                    "lat" => 0,
                    "long" => 0,
                    "place" => "<span class='noInfo'>Unknown place</span>",
                    "ids" => $entities
                ];
            }

            if (! in_array($psId, $mapData["0,0"]["ids"]["primarySource"])){
                $mapData["0,0"]["ids"]["primarySource"][] = $psId;
            }
        }
        return $mapData;
    }

    /**
     * This method allows to add a record of an original item to the array of time data
     * that can be used to generate a chronological map
     *
     * @param E\OriginalText $item
     * @param array $timeData
     * @param array $entities : array detailing which entities will appear on the heatmap ["originalText", "work"]
     * @return mixed
     */
    public function getTimeData(E\OriginalText $item, $timeData, $entities){

        // round up the date to the decade or replace it with the other rounded date
        $year = $item->getTpq() ? substr($item->getTpq(),0,-1)."0" : 0;
        $taq = $item->getTaq() ? substr($item->getTaq(),0,-1)."0" : 0;

        $oiId = "oi".$item->getId();

        $dataTemplate = ["year" => 0, "i" => "i", "ids" => []];
        foreach ($entities as $entity){
            $dataTemplate[$entity] = 0;
        }

        for ($date = $year; $date <= $taq; $date += 10) {
            if (! isset($timeData[$date])) {
                $timeData[$date]  = $dataTemplate;
                $timeData[$date]["year"] = $date;
            }

            if (! in_array($oiId, $timeData[$date]["ids"])){
                $timeData[$date]["ids"][] = $oiId;
                $timeData[$date]["originalText"] += 1;
            }
        }

        return $timeData;
    }

    /**
     * This method allows to add a record of a primary source (associated with an original item) to the array of time data
     * that can be used to generate a chronological map
     *
     * @param E\OriginalText $item
     * @param array $timeData
     * @param array $entities : array detailing which entities will appear on the heatmap ["primarySource", "work"]
     * @return mixed
     */
    public function getPrimarySourceTimeData(E\OriginalText $item, $timeData, $entities){
        if (! $item->getPrimarySource()){
            return $timeData;
        }
        $psId = "ps".$item->getPrimarySource()->getId();

        // round up the date to the decade
        $year = $item->getTpq() ? substr($item->getTpq(),0,-1)."0" : 0;
        $taq = $item->getTaq() ? substr($item->getTaq(),0,-1)."0" : 0;

        $dataTemplate = ["year" => 0, "i" => "i", "ids" => []];
        foreach ($entities as $entity){
            $dataTemplate[$entity] = 0;
        }

        for ($date = $year; $date <= $taq; $date += 10) {
            if (! isset($timeData[$date])) {
                $timeData[$date]  = $dataTemplate;
                $timeData[$date]["year"] = $date;
            }

            if (! in_array($psId, $timeData[$date]["ids"])){
                $timeData[$date]["ids"][] = $psId;
                $timeData[$date]["primarySource"] += 1;
            }
        }

        return $timeData;
    }

    /**
     * This methods returns an array that can be use to generate a "box record" with the box template
     * @param E\OriginalText $originalText
     * @param $withAstroObject boolean : does the astronomical object have to appear on the box?
     * @return array
     */
    function getBoxData(E\OriginalText $originalText, $withAstroObject = true){
        $placeName = "<span class='noInfo'>Unknown place</span>";
        if ($originalText->getPlace()){
            $place = $originalText->getPlace();
            $placeName = $place->toPublicString();
        }

        $shelfmark = "<span class='noInfo'>Unknown primary source</span>";
        if ($originalText->getPrimarySource()){
            $shelfmark = $originalText->getPrimarySource()->getBibref();
        }

        $boxData = [
            "id" => $originalText->getId(),
            "title" => $originalText->toPublicTitle(),
            "from" => $originalText->getTpq() ? $originalText->getTpq() : "?",
            "to" => $originalText->getTaq() ? $originalText->getTaq() : "?",
            "place" => $placeName,
            "shelfmark" => $shelfmark,
        ];

        if ($withAstroObject){
            $boxData["astroObject"] = $originalText->getAstronomicalObject() ?
                $originalText->getAstronomicalObject()->getId() : 0;
        }

        return $boxData;
    }

    /**
     * Returns a dataset that can be used to generate a DISHAS ChronoMap (Map+Heatmap)
     * @param E\OriginalText $originalText
     * @return array
     */
    public function getChronoMapData(E\OriginalText $originalText)
    {
        if (! $originalText)
            return [
                "chart" => [
                    ["type" => "Heatmap",
                        "data" => []],
                    ["type" => "Map",
                        "data" => []]
                ],
                "box" => []
            ];

        $workRepo = $this->getEntityManager()
            ->getRepository(E\Work::class);
        $primSourceRepo = $this->getEntityManager()
            ->getRepository(E\PrimarySource::class);

        $mapData = [];
        $timeData = [];
        $boxesData = [];

        $work = $originalText->getWork();
        $isWork = false;

        $dataTemplate = ["originalText" => [], "work" => []];
        $entities = ["originalText", "work"];

        if ($originalText->getPrimarySource()){
            $dataTemplate = ["primarySource" => [], "work" => []];
            $entities = ["primarySource", "work"];

            $primSource = $originalText->getPrimarySource();

            $mapData = $this->getPrimarySourcePlaceData($originalText, $mapData, $dataTemplate);
            $timeData = $this->getPrimarySourceTimeData($originalText, $timeData, $entities);
            $boxesData["ps".$primSource->getId()] = $primSourceRepo->getBoxData($primSource);
        } else {
            $mapData = $this->getPlaceData($originalText, $mapData, $dataTemplate);
            $timeData = $this->getTimeData($originalText, $timeData, $entities);
            $boxesData["oi".$originalText->getId()] = $this->getBoxData($originalText, false);
        }

        if ($work){
            $isWork = true;
            $boxesData["wo".$work->getId()] = $workRepo->getBoxData($work);

            $mapData = $workRepo->getPlaceData($work, $mapData, $dataTemplate);
            $timeData = $workRepo->getTimeData($work, $timeData, $entities);
        }

        if (count($timeData) != 0){
            $minDate = min(array_keys($timeData))-20;
            $maxDate = max(array_keys($timeData))+20;

            $timeDataStructure = ["year" => 0, "i" => "i", "ids" => []];
            foreach ($entities as $entity){
                $timeDataStructure[$entity] = 0;
            }

            for ($date = $minDate; $date <= $maxDate; $date += 10) {
                if (! isset($timeData[$date])){
                    $timeData[$date] = $timeDataStructure;
                    $timeData[$date]["year"] = $date;
                }
            }

            ksort($timeData);
        }

        /* In order to center the map on map points : retrieve geographic coordinates */
        $coords = array_keys($mapData);
        $lat = [];
        $long = [];
        foreach ($coords as $coord){
            list($lat[], $long[]) = explode(",", $coord);
        }

        return [
            "chart" => [
                ["type" => "Heatmap",
                    "data" => $timeData],
                ["type" => "Map",
                    "data" => $mapData]
            ],
            "box" => $boxesData,
            "isWork" => $isWork,
            "lat" => $lat,
            "long" => $long
        ];
    }

    /**
     * getMetadataTable
     *
     * this methods returns an array containing all the metadata of a original text necessary to constitute
     * the sidebar on the visualization page of a original text record.
     *
     * $metadata = ["title" => $title,
     *             ("subtitle" => $subtitle),
     *             ("comment" => $comment),
     *              "table type" => [$tableType], (astroObject + table type)
     *              "date" => [$tpaq],
     *              "place" => [$place], (placeName/id)
     *              "pages" => [$pagesMinMax], (min, max, number of pages)
     *              "scribe" => [$scribe], (actorName + actorNameOrigChar + tpq + taq + viaf)
     *              "work" => [$work], (title/incipit + tpq + taq + actorName + tpq + taq + viaf)
     *              "primary source" => [$primSource], (shelfmark + digitalIdentifier + primType + primTitle)
     *              "library" => [$library], (libraryName + city + country + isni)
     *              "edited text" => [$ediText], (editedTextTitle + date + type)
     *              "intellectual author" => [$historian], (firstName + lastName)
     *              "script" => [$script], (scriptName + iso15924)
     *              "language" => [$language], (languageName + iso6392)
     *              "user" => [$user]]
     *
     * @param E\OriginalText $origText
     * @return array
     * @throws \Exception
     */
    public function getMetadataTable(E\OriginalText $origText)
    {
        $metadata = [];
        $metadata["entity"] = "original_text";
        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);
        $originalTextName = $defRepo->getInterfaceName("originalText");
        $originalTextNames = $defRepo->getInterfaceName("originalText", true);

        /* UPPER PART OF THE SIDEBAR */
        $title = $origText->toPublicTitle();
        $metadata["title"] = $title;

        if ($origText->getOriginalTextTitleOriginalChar()){
            $metadata["subtitle"] = $origText->getOriginalTextTitleOriginalChar();
        }

        /* COMMENT */
        if ($origText->getComment()){
            $metadata["comment"] = $origText->getComment();
        }

        /* RELATED EDITIONS */
        $metadata["edition"] = "edited_texts.kibana_name+edited_texts.id";
        /*$filter = QG::newMultiMatchFilter(["original_texts.id","related_editions.original_texts.id"], $origText->getId());
        $editedTextName = $defRepo->getInterfaceName("editedText", true);
        $metadata["edition"] = [
            "json" => QG::setFilters([$filter]),
            "hover" => "Find all the $editedTextName of this $originalTextName",
            "title" => "All the $editedTextName of the $title"];*/

        $metadataTable = ["val" => [], "search" => ["json" => [], "hover" => "", "title" => []]];
        $urlTable = ["html" => "", "id" => "", "path" => ""];

        /* TABLE TYPE (astroObject + table type) */
        $tableTypeName = $defRepo->getInterfaceName("tableType");
        $metadata["$tableTypeName"] = $metadataTable;

        if ($origText->getTableType()){
            $metadata["$tableTypeName"]["val"][] = $urlTable;
            $metadata["$tableTypeName"]["val"][0]["html"] = $origText->getTableType()->toPublicString();
            $metadata["$tableTypeName"]["val"][0]["id"] = strval($origText->getTableType()->getId());
            $metadata["$tableTypeName"]["val"][0]["path"] = "tamas_astro_viewTableType";

            $filter = QG::newMatchFilter("table_type.keyword", $origText->getTableType()->toPublicTitle());
            $query = QG::setFilters([$filter]);
            $metadata["$tableTypeName"]["search"]["json"][] = $query;

            $metadata["$tableTypeName"]["search"]["hover"] = "Find all the $originalTextNames of the same type";
            $metadata["$tableTypeName"]["search"]["title"][] = "All $originalTextName of type ".$origText->getTableType()->getTableTypeName();
        } else {
            $metadata["$tableTypeName"]["val"][] = "";
        }

        /* DATE (tpq + taq) */
        $origTextTpq = $origText->getTpq() ? $origText->getTpq() : "?";
        $origTextTaq = $origText->getTaq() ? $origText->getTaq() : "?";

        $fieldname = $origTextTpq != $origTextTaq ? "timeframe of creation" : "date of creation";
        $values = [];
        $titles = [];
        $queries = [];
        $hover = $origTextTpq != $origTextTaq ? "Find all $originalTextNames created at the same period of time" : "Find all $originalTextNames created less than 25 years apart";

        if ($origTextTpq != "?" || $origTextTaq != "?"){
            $values[] = $origText->getTpaq();
            $titles[] = "All $originalTextNames created around ".$origText->getTpaq();

            list($filterTpq, $filterTaq) = QG::newTimerangeFilter($origTextTpq, $origTextTaq);
            $query = QG::setFilters([$filterTpq, $filterTaq]);
            $queries[] = $query;
        } else {
            $values[] = "";
        }

        $metadata[$fieldname] = GT::setMetadata($hover,$values,$queries,$titles);

        /* PLACE (placeName/id) */
        $fieldname = "place of creation";
        $values = [];
        $values[] = $origText->getPlace() ? $origText->getPlace()->toPublicString() : "";
        $hover = "Find all $originalTextNames created within a 100 km radius";
        $queries = [];

        if ($origText->getPlace()){
            $filter = QG::newGeoFilter($origText->getPlace()->getLat(),$origText->getPlace()->getLong());
            $query = QG::setFilters([$filter]);
            $queries[] = $query;

            $titles = ["All the $originalTextNames created in the area of ".$origText->getPlace()->toPublicString()];
        }

        $metadata[$fieldname] = GT::setMetadata($hover,$values,$queries,$titles);

        /* PAGES (pageMin + page Max + number of pages) */
        $pageMin = $origText->getPageMin() ? $origText->getPageMin() : "?";
        $pageMax = $origText->getPageMax() ? $origText->getPageMax() : "?";
        $nbPages = $origText->getNumberOfPages();

        $fieldname = GT::str_ends($pageMin,"r") || GT::str_ends($pageMin,"v") ? "foliotation" : "pages";
        $metadata[$fieldname] = $metadataTable;
        $pages = $pageMin != $pageMax ? "$pageMin-$pageMax ($nbPages p.)" : $pageMin;
        $metadata[$fieldname]["val"][] = $pages != "?" ? $pages : "";

        /* SCRIBE (actorName + actorNameOrigChar + tpq + taq + viaf) */
        if ($origText->getHistoricalActor()){
            $metadata["scribal agent"] = $metadataTable;
            $metadata["scribal agent"]["val"][] = $origText->getHistoricalActor()->toPublicString();
            $metadata["scribal agent"]["search"]["hover"] = "Find all $originalTextNames created by this agent";

            $filter = QG::newMatchFilter("historical_actor.kibana_id.keyword", "HistoricalActor".$origText->getHistoricalActor()->getId());
            $query = QG::setFilters([$filter]);
            $metadata["scribal agent"]["search"]["json"][] = $query;
            $metadata["scribal agent"]["search"]["title"][] = "All $originalTextNames written by ".$origText->getHistoricalActor()->toPublicTitle();
        }

        /* WORK (title/incipit + tpq + taq) */
        $workName = $defRepo->getInterfaceName("work");
        $metadata["$workName"] = $metadataTable;

        if ($origText->getWork()){
            $metadata["$workName"]["val"][] = $urlTable;
            $metadata["$workName"]["val"][0]["html"] = $origText->getWork()->toPublicString();
            $metadata["$workName"]["val"][0]["id"] = strval($origText->getWork()->getId());
            $metadata["$workName"]["val"][0]["path"] = "tamas_astro_viewWork";
            $metadata["$workName"]["search"]["hover"] = "Find all $originalTextNames originated from the same $workName";

            $filter = QG::newMatchFilter("work.id", $origText->getWork()->getId());
            $query = QG::setFilters([$filter]);
            $metadata["$workName"]["search"]["json"][] = $query;
            $metadata["$workName"]["search"]["title"][] = "All $originalTextNames originated from the $workName ".$origText->getWork()->toPublicTitle();
        } else {
            $metadata["$workName"]["val"][] = "";
        }

        /* AUTHOR OF THE WORK (actorName + tpq + taq) */
        if ($origText->getWork()){
            $actors = $origText->getWork()->getHistoricalActors() ? $origText->getWork()->getHistoricalActors() : [];
            $nActors = count($actors) <= 1 ? "" : "s" ;
            $fieldname = "author$nActors of the $workName";
            $hover = "Find all $originalTextNames originated from a $workName created by the same author";
            $values = count($actors) >= 1 ? [] : [""];
            $queries = [];
            $titles = [];

            if (count($actors) >= 1) {
                foreach ($actors as $actor){
                    $values[] = $actor->toPublicString();
                    $titles[] = "All the $originalTextNames originated from a $workName created by ".$actor->toPublicTitle();

                    $filter = QG::newMatchFilter("work.historical_actors.kibana_id.keyword", "HistoricalActor".$actor->getId());
                    $query = QG::setFilters([$filter]);
                    $queries[] = $query;
                }
            }
            $metadata[$fieldname] = GT::setMetadata($hover,$values,$queries,$titles);
        }

        /* PRIMARY SOURCE (shelfmark + digitalIdentifier + primType + primTitle) */
        $primSourceName = $defRepo->getInterfaceName("primarySource");
        $metadata["$primSourceName"] = $metadataTable;
        $primSource = $origText->getPrimarySource();
        $metadata["$primSourceName"]["val"] = $primSource ? [] : [""];

        if ($primSource){
            $metadata["$primSourceName"]["val"][] = $urlTable;
            $sourceName = $primSource->toPublicString();
            $metadata["$primSourceName"]["val"][0]["html"] = $sourceName;
            $metadata["$primSourceName"]["val"][0]["id"] = strval($primSource->getId());
            $metadata["$primSourceName"]["val"][0]["path"] = "tamas_astro_viewPrimarySource";
            $metadata["$primSourceName"]["search"]["hover"] = "Find all $originalTextNames originated from the same $primSourceName";

            $filter = QG::newMatchFilter("primary_source.id", $primSource->getId());
            $query = QG::setFilters([$filter]);
            $metadata["$primSourceName"]["search"]["json"][] = $query;

            $metadata["$primSourceName"]["search"]["title"][] = "All $originalTextNames originated from ".$primSource->toPublicTitle();
        }

        /* LIBRARY (libraryName + city + country + isni) */
        if ($primSource) {
            $metadata["library"] = $metadataTable;
            $library = $origText->getPrimarySource()->getLibrary();
            $metadata["library"]["val"][] = $library ? $library->toPublicString() : "";
            $metadata["library"]["search"]["hover"] = "Find all $originalTextNames kept in the same library";

            if ($library) {
                $filter = QG::newMatchFilter("primary_source.library.kibana_id.keyword", "Library".$library->getId());
                $query = QG::setFilters([$filter]);
                $metadata["library"]["search"]["json"][] = $query;

                $metadata["library"]["search"]["title"][] = "All $originalTextNames kept in ".$library->getLibraryName();
            }
        }

        /* SCRIPT (scriptName + iso15924) */
        $metadata["script"] = $metadataTable;
        $metadata["script"]["val"][] = $origText->getScript() ? $origText->getScript()->toPublicString() : "";
        $metadata["script"]["search"]["hover"] = "Find all $originalTextNames written in the same script";

        if ($origText->getScript()){
            $filter = QG::newMatchFilter("script.keyword", $origText->getScript()->__toString());
            $query = QG::setFilters([$filter]);
            $metadata["script"]["search"]["json"][] = $query;
            $metadata["script"]["search"]["title"][] = "All $originalTextNames written in ".$origText->getScript()->getScriptName();
        }

        /* LANGUAGE (languageName + iso6392) */
        $metadata["language"] = $metadataTable;
        $metadata["language"]["val"][] = $origText->getLanguage() ? $origText->getLanguage()->toPublicString() : "";
        $metadata["language"]["search"]["hover"] = "Find all $originalTextNames written in the same language";

        if ($origText->getLanguage()){
            $filter = QG::newMatchFilter("language.keyword", $origText->getLanguage()->__toString());
            $query = QG::setFilters([$filter]);
            $metadata["language"]["search"]["json"][] = $query;
            $metadata["language"]["search"]["title"][] = "All $originalTextNames written in ".$origText->getLanguage()->getLanguageName();
        }

        /* USER (username/id) */
        $metadata["author of the record"] = $metadataTable;
        $username = $origText->getCreatedBy()->toPublicString();
        $metadata["author of the record"]["val"][] = $username;

        return $metadata;
    }



    // ==================================================================== draft =====================================================================//
    // this function is still a work in progress ! It used to work in an earlier version of the work,
    // but due to change of usage, it is no longer accessible by the public.
    // Today, the search in the database is only made by handsontable.
    /* _____________________________________________________________ search originalText ________________________________________________________ */

/**
 * listGetMethod
 *
 * This method returns an array of the getMethod of an object.
 *
 * @param object $object
 * @return array (array of string)
 */
    /*
     * public function listGetMethod($object) {
     * $methodNotToCheck = ["getUpdatedBy", "getCreatedBy", "getUpdated", "getCreated", "getPublic", "getComment"]; //We don't check on these fields, which are not connected to the actual information
     * $methodNames = array();
     * foreach (get_class_methods(get_class($object)) as $methodName) {
     * if (preg_match("/^get/", $methodName) && !in_array($methodName, $methodNotToCheck)) {
     * $methodNames[] = $methodName;
     * }
     * }
     * return $methodNames;
     * }
     */
/**
 * loopForSearch
 *
 * This method is called by findResultsBySearch and itself.
 * For a given object, it checks on all the "authorized" method (we discriminate some of them). Foreach $object->method() it checks whether the result is an object or a string.
 * a) if $object->method() is an object, the loopForSearch method is called again with $object->method() as object.
 * b) if it is a string, it builds a query depending on the field and the argument.
 * The function doesn't return anything. It builds the correct object queryBuilder as an instruction used in findResultsBySearch function.
 *
 * @param object $object
 *            (starts with originalText object, and is called by each of its objects).
 * @param object $qb
 * @param string $tableName
 * @param string $action
 *            ("search" or "findDuplicate")
 */
    /*
     * public function loopForSearch($object, $qb, $tableName, $action) {
     * $methodNotToCheck = ["getTableType", "getUpdatedBy", "getCreatedBy", "getUpdated", "getCreated", "getPublic", "getComment"]; //We don't check on these fields, which are not connected to the actual information
     *
     * $methodNames = $this->listGetMethod($object, $methodNotToCheck);
     * //1. We check if the object has an id. If yes, we only search for this id in the database, and don't check on all the other fields of the object.
     * if ($object->getId() !== null) {
     * $qb->andWhere($tableName . ".id =:" . $tableName . "id" . $this->count);
     * $this->parameters[$tableName . "id" . $this->count] = intval($object->getId());
     *
     * return;
     * }
     * //2. We compare each object field by field.
     * foreach ($methodNames as $methodName) {
     *
     * //2.1. We check on null only when we check duplicates. We don't check null fields when we do simple search
     * if ($action == "search" && $object->{$methodName}() === null) {
     * continue;
     * }
     * // 2.2. We don't compare Id's if they are not filled. We don't compare some of the methods when they are not relevant to define the originalText most distinct features.
     * if (($methodName == "getId" && $object->{$methodName}() === null) || in_array($methodName, $methodNotToCheck)) {
     * continue;
     * }
     * $this->count++;
     * $fieldName = lcfirst(substr($methodName, 3));
     * //2.3. We check if $object->method() is object
     * if (is_object($object->{$methodName}())) {
     * //2.3.1. In "array collection" case
     * if ($object->{$methodName}() instanceof \Doctrine\Common\Collections\ArrayCollection) {
     * $object->{$methodName}()->toArray();
     * // in the case of array collection, we have to delete the final "s" at the end of the name.
     * foreach ($object->{$methodName}() as $subField) {
     * $joinTableName = $tableName . lcfirst(substr($fieldName, 0, -1)) . $this->count;
     * $qb->leftJoin($tableName . "." . $fieldName, $joinTableName);
     * $this->loopForSearch($subField, $qb, $joinTableName, $action);
     * $this->count++;
     * }
     * continue;
     * }
     * //2.3.2. In case of object is null
     * elseif ($action == "findDuplicate" && method_exists($object->{$methodName}(), 'checkIfNull') && $object->{$methodName}()->checkIfNull()) {
     * $qb->andWhere($tableName . "." . $fieldName . " IS NULL");
     * continue;
     * }//2.3.3. In any other case
     * else {
     * $joinTableName = $tableName . lcfirst($fieldName) . $this->count;
     * $qb->leftJoin($tableName . "." . $fieldName, $joinTableName);
     * $this->loopForSearch($object->{$methodName}(), $qb, $joinTableName, $action);
     * continue;
     * }
     * }
     * //2.4. We check if object->method() is string
     * elseif (is_string($object->{$methodName}())) {
     * $qb->andWhere($tableName . "." . $fieldName . " =:" . $fieldName . $this->count);
     * $this->parameters[$fieldName . $this->count] = $object->{$methodName}();
     * continue;
     * }
     * //2.5. We check if object->method() is null
     * elseif (null == $object->{$methodName}()) {
     * $qb->andWhere($tableName . "." . $fieldName . " IS NULL");
     * }
     * }
     * }
     *
     */

/**
 * findResultsBySearch
 *
 * This method is called by various method of the admin controller (adminAddOriginalText, adminSearchOriginalText).
 * This method finds object of class originalTexts persisted in database.
 * It calls loopForSearch method of this class.
 * Depending on the $action (search or find duplicate), the behaviour of the loopForSearch is slightly different.
 * a) if $action is "search" : the search is not applied to the null field of the form.
 * b) if $action is "findDuplicate" : the search is also applied to the null field of the form.
 *
 * @param object $object
 *            (object of class $originalText).
 * @param string $action
 *            ("search" or "findDuplicate")
 * @return array (array of objects of class $originalText).
 */
    /*
     * public function findResultsBySearch($object, $action) {
     * $tableName = lcfirst((new \ReflectionClass($object))->getShortName());
     * $qb = $this->createQueryBuilder($tableName);
     * $this->loopForSearch($object, $qb, $tableName, $action);
     * $qb->setParameters($this->parameters);
     * $result = $qb->getQuery()->getResult();
     * return $result;
     * }
     */
}
