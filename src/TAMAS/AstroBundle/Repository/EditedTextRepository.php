<?php

namespace TAMAS\AstroBundle\Repository;

use TAMAS\AstroBundle\DISHASToolbox\GenericTools as GT;
use TAMAS\AstroBundle\DISHASToolbox\QueryGenerator as QG;
use TAMAS\AstroBundle\DISHASToolbox\Table\TAMASListTableTemplate;
use TAMAS\AstroBundle\Entity as E;
use TAMAS\AstroBundle\Entity\OriginalText;

/**
 * editedTextRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EditedTextRepository extends \Doctrine\ORM\EntityRepository
{

    /* __________________________________________ add data _____________________________________________ */

    /**
     * prepareListForForm
     *
     * This method is used when the current entity is linked to a parent form.
     * It returns a custom DQL query builder (not the result!) which will be queried from the formType and findForAutofill.
     *
     * @param $option
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function prepareListForForm($option)
    {
        $query = $this->createQueryBuilder('e')
            ->leftJoin('e.tableType', 'tt')
            ->leftJoin('e.historian', 'h')
            ->addSelect('h');
        if ($option) {
            $thatOption = json_decode($option, true);
            $allowedType = $thatOption['allowedType'];
            $id = $thatOption['id'];
            $query->where('e.type IN (:type)');
            $parameters = [
                'type' => $allowedType
            ];
            if ($id) { // in the case of an edition, we don't want the present object to be linkable with itself.
                $query->andWhere('e.id != :id ');
                $parameters['id'] = $id;
            }

            if (isset($thatOption['tableType']) && $thatOption['tableType']) {

                $tableType = $thatOption['tableType'];
                $query->andWhere('tt.id = :tableType');
                $parameters['tableType'] = $tableType;
            }
            $query->setParameters($parameters);
        }
        $query->orderBy('e.editedTextTitle', 'ASC');
        return $query;
    }

    /**
     * findForAutofill
     *
     * This method is triggered in the parent entity form type by ajax. It returns the getLabeld list of object of the entity class.
     * In this case an option can be passed to the method: the type of editedText requested which can change depending on the type of the paraent editedText.
     *
     * @param string (json) $option (the allowed type to request in this situation : [a, b, c] if parent editedText = b, [a, c] if parent editedText = c.
     * @return array (each value of the array contains an id and a title which are used in the ajax request to populate the select choice of the form such as <selec><option = "id">title</option>).
     */
    public function findForAutofill($option = null)
    {
        $queryResult = $this->prepareListForForm($option)
            ->getQuery()
            ->getResult();
        $arrayResult = [];
        foreach ($queryResult as $editedText) {
            $tableTypeId = '';
            if ($editedText->getTableType() && $editedText->getTableType()->getId()) {
                $tableTypeId = $editedText->getTableType()->getId();
            }
            $result = [
                'id' => $editedText->getId(),
                'title' => (string) $editedText,
                'tableTypeId' => $tableTypeId
            ];
            if (!$editedText->getPublic()) {
                $result += [
                    'draft' => 'draft'
                ];
            }
            $arrayResult[] = $result; // ];
        }
        return $arrayResult;
    }

    /* __________________________________________________ list data ___________________________________________________ */

    /**
     * getList
     *
     * This method is roughly equivalent to findAll(), but it lowers the number of queries to the database by selecting only the field that we are interested in displaying.
     *
     * @return array (editedText objects)
     */
    public function getList($relatedEditions = false)
    {


        $query = $this->createQueryBuilder('e')
            ->leftJoin('e.secondarySource', 'ss')
            ->addSelect('ss')
            ->leftJoin('ss.historians', 'hi')
            ->addSelect('hi')
            ->leftJoin('e.historian', 'h')
            ->addSelect('h')
            ->leftJoin('e.tableContents', 'tc')
            ->addSelect('tc')
            ->leftJoin('tc.meanMotion', 'mm')
            ->addSelect('mm')
            ->leftJoin('e.originalTexts', 'ot')
            ->addSelect('ot')
            ->leftJoin('ot.primarySource', 'ps')
            ->addSelect('ps')
            ->leftJoin('ps.library', 'lb')
            ->addSelect('lb')
            ->leftJoin('ot.work', 'w')
            ->leftJoin('w.historicalActors', 'wh')
            ->addSelect('wh')
            ->addSelect('w')
            ->leftJoin('tc.parameterSets', 'pst')
            ->addSelect('pst')
            ->leftJoin('pst.parameterValues', 'pv')
            ->addSelect('pv')
            ->leftJoin('e.createdBy', 'f')
            ->addSelect('f')
            ->leftJoin('e.updatedBy', 'u')
            ->addSelect('u');
        if ($relatedEditions) {
            $query->leftJoin('e.relatedEditions', 're')
                ->addSelect('re');
        }
        $query = $query->orderBy('e.id')
            ->getQuery()
            ->getResult();
        return $query;
    }

    /**
     * getEditedTextByParameter
     *
     * This types of methods enable to query from the inverse side of a relation when it is not possible from the entity class methods.
     * This method gets a list of editedText object depending on the parameter set it uses.
     *
     * @param object $parameterSet
     * @return array : array of editedTexts objects
     */
    public function getEditedTextByParameter($parameterSet)
    {
        return $this->createQueryBuilder('et')
            ->leftJoin('et.originalTexts', 'o')
            ->addSelect('o')
            ->leftJoin('o.primarySource', 'pr')
            ->addSelect('pr')
            ->leftJoin('pr.library', 'l')
            ->leftJoin('et.tableContents', 'tc')
            ->addSelect('tc')
            ->leftJoin('tc.parameterSets', 'ps')
            ->addSelect('ps')
            ->leftJoin('et.secondarySource', 'ss')
            ->addSelect('ss')
            ->leftJoin('ss.historians', 'h')
            ->addSelect('h')
            ->leftJoin('et.historian', 'hi')
            ->addSelect('hi')
            ->where('ps.id = :id')
            ->setParameter('id', $parameterSet->getId())
            ->getQuery()
            ->getResult();
    }

    /**
     * getFormattedList
     *
     * This method formats an array of a given entity objects in order to show it on a list (a table in our twig interface).
     * This format is not an easy task from the front-end, and is much easier when it is possible to call other method from different repository (e.g. : getLabel).
     * Hence, this method lowers the number of code line / the number of query to the database / make the method mutualized and so lower the amont of mistake in case of evolution of the code.
     *
     * @param array $editedTexts
     *            (objects).
     * @return array (formatted editedText properties)
     */
    public function getFormatedList($editedTexts)
    {
        $formattedEditedText = [];
        foreach ($editedTexts as $editedText) {
            $scholarRef = [];
            $originalTexts = [];
            $updatedBy = [];
            $createdBy = [];
            $type = "";
            $year = "";
            $public = $editedText->getPublic();
            $created = "";
            $updated = "";
            $bibRef = null;
            $parameterSets = [];
            $tableContents = [];
            $title = [
                'id' => $editedText->getId(),
                'entity' => 'editedText',
                'public' => $public
            ];
            if ($editedText->getCreated()) {
                $created = $editedText->getCreated()->format('d-m-Y');
            }
            if ($editedText->getUpdated()) {
                $updated = $editedText->getUpdated()->format('d-m-Y');
            }
            if ($editedText->getCreatedBy()) {
                $createdBy = [
                    'id' => $editedText->getCreatedBy()->getId(),
                    'username' => $editedText->getCreatedBy()->getUsername()
                ];
            }
            if ($editedText->getUpdatedBy()) {
                $updatedBy = [
                    'id' => $editedText->getUpdatedBy()->getId(),
                    'username' => $editedText->getUpdatedBy()->getUsername()
                ];
            }
            if ($editedText->getSmallEditedTextTitle()) {
                $title['title'] = $editedText->getSmallEditedTextTitle();
            } elseif ($editedText->getEditedTextTitle()) {
                $title['title'] = $editedText->getEditedTextTitle();
            } else {
                $title['title'] = "Unknown text n°" . $editedText->getId();
            }
            if ($editedText->getType()) {
                $type = $editedText->getType();
            }
            if ($editedText->getDate()) {
                $year = $editedText->getDate();
            }
            if ($editedText->getSecondarySource()) {
                $secondarySource = $editedText->getSecondarySource();
                $bibRef = (string) $editedText->getSecondarySource();
                foreach ($secondarySource->getHistorians() as $historian) {
                    $scholarRef[] = (string) $historian;
                }
            }
            if ($editedText->getHistorian()) {
                $scholarRef[] = (string) $editedText->getHistorian();
            }
            foreach ($editedText->getOriginalTexts() as $originalText) {
                $originalTexts[] = [
                    'id' => $originalText->getId(),
                    'title' => (string) $originalText,
                    'entity' => 'originalText',
                    'public' => $originalText->getPublic()
                ];
            }
            foreach ($editedText->getTableContents() as $tableContent) {
                $tableContents[] = [
                    'title' => $tableContent->getTitle(),
                    'id' => $tableContent->getId(),
                    'public' => $tableContent->getPublic(),
                    'entity' => 'tableContent'
                ];
                foreach ($tableContent->getParameterSets() as $parameterSet) {
                    $parameterTitle = $parameterSet->getTitle();
                    $parameterSets[$parameterSet->getId()] = [
                        'id' => $parameterSet->getId(),
                        'entity' => 'parameterSet',
                        'title' => $parameterTitle
                    ];
                }
            }

            $parameterSets = array_values($parameterSets);
            $formattedEditedText[] = [
                'id' => $editedText->getId(),
                'public' => $public,
                'created' => $created,
                'updated' => $updated,
                'title' => $title,
                'type' => $type,
                'year' => $year,
                'bibRef' => $bibRef,
                'scholarRef' => $scholarRef,
                'originalTexts' => $originalTexts,
                'tableContents' => $tableContents,
                'parameterSets' => $parameterSets,
                'createdBy' => $createdBy,
                'updatedBy' => $updatedBy
            ];
        }
        return $formattedEditedText;
    }

    /**
     * getObjectList
     *
     * This function generates the specs for listing a given collection of editedTexts: both the list of data
     * (pre-treated for the front library) and the spec of the table (adapted to the front library).
     *
     * @param array $editedTexts : collection of all the edited texts
     * @return array
     */
    public function getObjectList($editedTexts)
    {
        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);
        $fieldList = [
            new TAMASListTableTemplate('id', '#'),
            new TAMASListTableTemplate('title', 'Title', ['class' => ['link']]),
            new TAMASListTableTemplate('type', 'Edition type'),
            new TAMASListTableTemplate('year', 'Year'),
            new TAMASListTableTemplate('bibRef', 'Bib. ref.'),
            new TAMASListTableTemplate('scholarRef', 'Author(s)', ['class' => ['list']]),
            new TAMASListTableTemplate('originalTexts', ucfirst($defRepo->getInterfaceName("originalText", true)), ['class' => ['link', 'list']]),
            new TAMASListTableTemplate('tableContents', ucfirst($defRepo->getInterfaceName("tableContent", true)), ['class' => ['link', 'list']]),
            new TAMASListTableTemplate('parameterSets', ucfirst($defRepo->getInterfaceName("parameterSet", true)), ['class' => ['link', 'list']]),
            new TAMASListTableTemplate('created', 'Created', [], 'adminInfo'),
            new TAMASListTableTemplate('updated', 'Updated', [], 'adminInfo'),
            new TAMASListTableTemplate('buttons', '', [], 'editDelete')
        ];
        $data = $this->getFormatedList($editedTexts);

        return [
            'fieldList' => $fieldList,
            'data' => $data
        ];
    }

    /**
     * Returns a field list used in the results page in the front office
     * in order to generates a DataTable of the results on a query to elasticsearch
     *
     * The name provides the location in an array where DataTable will find the information to display
     *
     * The title corresponds to the column label associated with the information
     *
     * The properties defines how the cell content will be formatted :
     * 		- class (will surround the text in a <span class="__"></span>) :
     * 			* number : in order to align the text to the right
     * 			* title-italic : to style the text of the cell in italic
     *          * uppercase : to style the text of the cell in uppercase letter
     *          * truncate : truncate all strings superior to 120 characters
     *          * capitalize : capitalize the first letter of the string
     * 		- path + id :
     * 			* path : routing path to generate a link
     * 			* id : location of the id in the result object
     * 		- unknown : text to display if there is no information provided in the results)
     *
     * Source defines which fields will appear in the elasticsearch response
     * corresponding to the fields that are added to the array associated with the key "source" in the query
     * (multiple fields can be added for a single column with "+")
     *
     * @return array of TAMASListTableTemplate objects
     */
    public function getPublicObjectList()
    {
        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);
        return [
            new TAMASListTableTemplate('id', '#'),
            new TAMASListTableTemplate(
                'edited_text_title',
                'Title',
                ['path' => 'tamas_astro_viewTableEdition', 'id' => 'id']
            ),
            new TAMASListTableTemplate(
                'table_type',
                ucfirst($defRepo->getInterfaceName("tableType")),
                ['path' => 'tamas_astro_viewTableType', 'id' => "table_type.id"],
                '',
                "table_type.kibana_name+table_type.id"
            ),
            new TAMASListTableTemplate('type', 'Edition type', ['class' => ['uppercase']]),
            new TAMASListTableTemplate('date', 'Edition year', ['class' => ['number']]),
            new TAMASListTableTemplate(
                'intellectual_authors',
                ucfirst($defRepo->getInterfaceName("historian", true)),
                ['unknown' => "No " . $defRepo->getInterfaceName("historian") . " provided"]
            )
        ];
    }

    /* __________________________________________________ prepare data for form ___________________________________________________ */

    /**
     * findRelatedEditionTypes
     *
     * This method find what are the allowed type of relatedEditions for one editedText.
     * if text = a : none ; if text = b : a, b, c ; if text = c : a, c.
     * We also add in the research option the identifier of the object if it is known:
     * we exclude this identifier in the query in order not to be able to link an edition with itself while editing it.
     *
     * @param $editedText
     * @return false|string : json string
     */
    public function findRelatedEditionTypes($editedText)
    {
        if ($editedText->getId()) {
            $id = $editedText->getId(); // in the case of an edition, we don't want the present object to be linkable with itself.
        } else {
            $id = null;
        }
        $type = $editedText->getType();
        if ($type == "a") {
            $allowedType = null;
        } elseif ($type == "b") {
            $allowedType = [
                "a",
                "b",
                "c"
            ];
        } elseif ($type == "c") {
            $allowedType = [
                "a",
                "c"
            ];
        }
        $option = [
            'allowedType' => $allowedType,
            'id' => $id
        ];
        return $option = json_encode($option);
    }

    /* ________________________________________________________________________ Form Validation _____________________________________________________________________ */

    /**
     * findUniqueEntity
     *
     * This method is used by UniqueEntity validation rule. UniqueEntity doesn't work well for many to many relation embedded entity.
     *
     * @param array $criteria
     *            (value from the form to compare)
     * @return array $queryResult (array of work objects matching the criteria)
     */
    public function findUniqueEntity($criteria)
    {
        $editedTextTitle = $criteria['editedTextTitle'];
        $date = $criteria['date'];
        $type = $criteria['type'];
        $tableContents = $criteria['tableContents'];
        return $this->createQueryBuilder('e')
            ->leftJoin('e.tableContents', 't')
            ->addSelect('t')
            ->where('e.editedTextTitle =:editedTextTitle')
            ->andWhere('e.date =:date')
            ->andWhere('e.type =:type')
            ->andWhere('t.id IN (:tableContents)')
            ->setParameters([
                'tableContents' => $tableContents,
                'date' => $date,
                'type' => $type,
                'editedTextTitle' => $editedTextTitle
            ])
            ->getQuery()
            ->getResult();
    }

    public function forceDelete(E\EditedText $editedText)
    {
        $this->getDoctrine()
            ->getManager()
            ->remove($editedText);
        $this->getDoctrine()
            ->getManager()
            ->flush();
    }

    /**
     * getDependencies
     *
     * This method is part of the process of forcing deletion of an object.
     * We need to know what are the related fields that are linked to editedText (in order to unlink it before deleting it)
     *
     * @return array
     */
    public function getDependancies()
    {
        return [
            E\EditedText::class => [
                'relatedEditions' => [
                    'unlinkMethod' => 'removeRelatedEdition',
                    'oneToMany' => false
                ]
            ],
            E\TableContent::class => [
                'editedText' => [
                    'unlinkMethod' => 'setEditedText',
                    'oneToMany' => true
                ]
            ]
        ];
    }

    public function getListForTree()
    {
        $query = $this->createQueryBuilder('e')
            ->leftJoin('e.originalTexts', 'ot')
            ->addSelect('ot')
            ->leftJoin('e.tableType', 'tt')
            ->addSelect('tt')
            ->leftJoin('e.relatedEditions', 're')
            ->addSelect('re')
            ->orderBy('e.id')
            ->getQuery()
            ->getResult();
        return $query;
    }

    /* ______________________________________________________________________________ DependanceTree = graph _________________________________________ */
    public function getDependanceTree()
    {
        $dependenceTree = [];
        //$editedTexts = $this->getList(true);
        $editedTexts = $this->getListForTree();
        if ($editedTexts && !empty($editedTexts)) {
            foreach ($editedTexts as $editedText) {
                $tableType = '';
                if ($editedText->getTableType()) {
                    $tableType = $editedText->getTableType()->getId();
                }
                $children = [];
                foreach ($editedText->getRelatedEditions() as $child) {
                    $children[] = 'e' . $child->getId();
                }
                foreach ($editedText->getOriginalTexts() as $child) {
                    $children[] = 'o' . $child->getId();
                }
                $visLabel = (string) $editedText;
                $dependenceTree['e' . $editedText->getId()] = [
                    'children' => $children,
                    'type' => 'editedText',
                    'id' => $editedText->getId(),
                    'public' => $editedText->getPublic(),
                    'option' => [
                        'tableType' => $tableType,
                        'editionType' => $editedText->getType(),
                        'visLabel' => $visLabel
                    ]
                ];
            }
        }
         /* $originalTexts = $this->getEntityManager()
            ->getRepository(E\OriginalText::class)
            ->getList(); */


        $originalText = OriginalText::class;
        $originalTextRepo =  $this->getEntityManager()->getRepository(OriginalText::class);
        $qu = $originalTextRepo->createQueryBuilder('o')
            ->leftJoin('o.tableType', 'tt')
            ->addSelect('tt')
            ->leftJoin('o.work', 'w')
            ->addSelect('w')
            ->leftJoin('o.primarySource', 'ps')
            ->addSelect('ps')
            ->leftJoin('ps.library', 'l')
            ->addSelect('l');
         $originalTexts = $qu->getQuery()->getResult();
        if ($originalTexts && !empty($originalTexts)) {
            foreach ($originalTexts as $originalText) {
                $tableType = '';
                if ($originalText->getTableType()) {
                    $tableType = $originalText->getTableType()->getId();
                }
                $visLabel = (string) $originalText;
                $dependenceTree['o' . $originalText->getId()] = [
                    'children' => [],
                    'type' => 'originalItem',
                    'id' => $originalText->getId(),
                    'public' => $originalText->getPublic(),
                    'option' => [
                        'tableType' => $tableType,
                        'editionType' => null,
                        'visLabel' => $visLabel
                    ]
                ];
            }
        }
        return json_encode($dependenceTree);
    }

    /**
     * This methods returns an array that can be use to generate a "box record" with the box template
     * @param E\EditedText $editedText
     * @return array
     */
    function getBoxData(E\EditedText $editedText)
    {
        $date = $editedText->getDate();

        return [
            "id" => $editedText->getId(),
            "title" => $editedText->getTitle() ? $editedText->getTitle() : "Table edition n°" . $editedText->getId(),
            "type" => "Type " . ucfirst($editedText->getType()),
            "author" => $editedText->getFormattedIntellectualAuthors(),
            "date" => $date ? $date : "<span class='noInfo'>Undated edition</span>",
        ];
    }

    /**
     * This method returns all the records that are related to an edition, i.e. all the editions and original texts
     * on which the edition given as parameter is based upon
     *
     * @param E\EditedText $editedText
     * @return array
     */
    public function getEditionBases(E\EditedText $editedText)
    {
        if (!$editedText)
            return [];

        $dependenceTree = $this->getDependanceTree();
        $graph = new \TAMAS\AstroBundle\DISHASToolbox\Graph\TAMASGraph();
        $graph->loadJSONTree($dependenceTree);

        $editionNode = $graph->getNode('e' . $editedText->getId()); // find the node corresponding to the edited text
        return $editionNode->getDescendants(); // find the records related to this node
    }

    /**
     * getTableEditions
     *
     * this method returns an array of all the editions on which an edited text is based upon
     *
     * @param E\EditedText $editedText
     * @param bool $onlyPublic
     * @return array
     */
    public function getTableEditions(E\EditedText $editedText, bool $onlyPublic = true)
    {
        if (!$editedText)
            return [];

        $baseEditions = $this->getEditionBases($editedText); // find the records related to this node

        $editionBases = [];
        foreach ($baseEditions as $baseEdition) {
            if (GT::str_begins($baseEdition->getLabel(), "e")) {
                $base = $this->findBy(['id' => str_replace("e", "", $baseEdition->getLabel())])[0];

                if ($onlyPublic) {
                    // fill the array with all the edition bases corresponding to the id only if the base is public
                    if ($base->getPublic()) $editionBases[] = $base;
                } else {
                    // fill the array with all the edition bases corresponding to the id
                    $editionBases[] = $base;
                }
            }
        }

        // sort the editions by date
        usort($editionBases, array('TAMAS\AstroBundle\DISHASToolbox\GenericTools', 'compareDate'));

        return $editionBases;
    }

    /**
     * getOriginalTexts
     *
     * this method returns an array of all the original texts on which an edited text is based upon
     *
     * @param E\EditedText $editedText
     * @param bool $onlyPublic
     * @return array
     */
    public function getOriginalTexts(E\EditedText $editedText, bool $onlyPublic = true)
    {
        $oiRepo = $this->getEntityManager()->getRepository(E\OriginalText::class);
        $baseItems = $this->getEditionBases($editedText); // find the records related to this node

        $originalBases = [];
        foreach ($baseItems as $baseItem) {
            if (GT::str_begins($baseItem->getLabel(), "o")) {
                $base = $oiRepo->findBy(['id' => str_replace("o", "", $baseItem->getLabel())])[0];

                if ($onlyPublic) {
                    // fill the array with all the original texts corresponding to the id only if the base is public
                    if ($base->getPublic()) $originalBases[] = $base;
                } else {
                    // fill the array with all the original texts corresponding to the id
                    $originalBases[] = $base;
                }
            }
        }

        // sort the editions by date
        usort($originalBases, array('TAMAS\AstroBundle\DISHASToolbox\GenericTools', 'compareTpq'));

        return $originalBases;
    }

    /**
     * This method generates a dataset that can be used to generate a ChronoMap to visualize all the primary sources
     * and work that were used in a table edition
     *
     * @param E\EditedText $editedText
     * @return array
     */
    public function getChronoMapData(E\EditedText $editedText)
    {
        $origItems = $this->getOriginalTexts($editedText);
        // Check if there is original items associated with the parameter set
        if (count($origItems) == 0)
            return [];

        $origItemRepo = $this->getEntityManager()->getRepository(E\OriginalText::class);
        $workRepo = $this->getEntityManager()->getRepository(E\Work::class);
        $primSourceRepo = $this->getEntityManager()->getRepository(E\PrimarySource::class);

        $boxesData = [];
        $mapData = [];
        $timeData = [];
        $workId = 0;
        $isPrimSource = null;
        $isWork = null;
        foreach ($origItems as $item) {
            $primSource = $item->getPrimarySource();
            if ($primSource) {
                $isPrimSource = true;
                $boxesData["ps" . $primSource->getId()] = $primSourceRepo->getBoxData($primSource);
                $mapData = $origItemRepo->getPrimarySourcePlaceData($item, $mapData, ["primarySource" => [], "work" => []]);
                $timeData = $origItemRepo->getPrimarySourceTimeData($item, $timeData, ["primarySource", "work"]);
            }

            $work = $item->getWork();
            if ($work) {
                if ($work->getId() != $workId) {
                    $isWork = true;
                    $workId = $work->getId();
                    $boxesData["wo" . $work->getId()] = $workRepo->getBoxData($work);
                    $mapData = $workRepo->getPlaceData($item->getWork(), $mapData, ["primarySource" => [], "work" => []]);
                    $timeData = $workRepo->getTimeData($item->getWork(), $timeData, ["primarySource", "work"]);
                }
            }
        }

        if (count($timeData) != 0) {
            $minDate = min(array_keys($timeData)) - 20;
            $maxDate = max(array_keys($timeData)) + 20;

            for ($date = $minDate; $date <= $maxDate; $date += 10) {
                if (!isset($timeData[$date])) {
                    $timeData[$date] = ["year" => $date, "i" => "i", "ids" => [], "primarySource" => 0, "work" => 0];
                }
            }

            ksort($timeData);
        }

        return [
            "chart" => [
                [
                    "type" => "Heatmap",
                    "data" => $timeData
                ],
                [
                    "type" => "Map",
                    "data" => $mapData
                ]
            ],
            "box" => $boxesData,
            "isWork" => $isWork,
            "isPrimSource" => $isPrimSource
        ];
    }

    /**
     * Generates dataset for the DishasGraph edition tree for the table edition record page in the front office
     * @param E\EditedText $editedText
     * @return array
     */
    public function getGraphData(E\EditedText $editedText)
    {
        $origItems = $this->getOriginalTexts($editedText);
        $editions = $editedText->getRelatedEditions()->toArray();
        if (count($origItems) == 0 && count($editions) == 0) {
            return [];
        }

        $graph = new \TAMAS\AstroBundle\DISHASToolbox\Graph\TAMASGraph();
        $graph->loadJSONTree($this->getDependanceTree());

        $editionNode = $graph->getNode('e' . $editedText->getId());
        $graphData = $this->getChildrenData($editionNode);
        $treeData = $graphData[0];
        $ids = $graphData[1];
        $treeData["fixed"] = true;
        $treeData["x"] = "50%";
        $treeData["y"] = "50%";
        $treeData["id"] = array_values(array_diff($ids, ['et' . $editedText->getId()])); // remove the id of the current edition
        $treeData["title"] = "Current\nedition";

        $boxes = [];
        $origItemRepo = $this->getEntityManager()->getRepository(E\OriginalText::class);
        foreach ($origItems as $origText) {
            $boxes["oi" . $origText->getId()] = $origItemRepo->getBoxData($origText, false);
        }
        foreach ($editions as $edition) {
            $boxes["et" . $edition->getId()] = $this->getBoxData($edition);
        }

        return [
            "chart" => [[
                "type" => "Graph",
                "data" => [$treeData]
            ]],
            "box" => $boxes
        ];
    }

    /**
     * Recursive function returning an array that can be used to generate a force-oriented tree graph
     * for visualizing the edition bases of an edited text in the front office
     * @param $node
     * @param array $ids
     * @return array
     */
    public function getChildrenData($node, $ids = [])
    {
        $treeData = [];
        $isEditedText = GT::str_begins($node->getLabel(), "e");
        $prefix = $isEditedText ? "e" : "o";

        // if the current node is not public yet
        if (!($node->isPublic())) {
            return [$treeData, $ids];
        }

        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);

        $treeData["name"] = $node->getOption()["visLabel"];
        $treeData["picto"] = $isEditedText ? "/img/pictograms/editedText.png" : "/img/pictograms/originalText.png";
        $treeData["color"] = $isEditedText ? $defRepo->find(3)->getUserInterfaceColor() : $defRepo->find(11)->getUserInterfaceColor();

        $id = $isEditedText ? "et" . str_replace($prefix, "", $node->getLabel()) : "oi" . str_replace($prefix, "", $node->getLabel());
        $treeData["id"] = [$id];
        $ids[] = $id;

        $children = $node->getChildren();
        if ($children) {
            $treeData["children"] = [];
            foreach ($children as $child) {
                $data = $this->getChildrenData($child, $ids);
                $treeData["children"][] = $data[0];
                $ids = $data[1];
            }
        } else {
            $treeData["value"] = 1;
        }

        return [$treeData, $ids];
    }

    /**
     * This method returns the metadata associated with the editorial context of an edition
     * @param E\EditedText $editedText
     * @return array
     * @throws \Exception
     */
    public function getMetadataTable(E\EditedText $editedText)
    {
        $metadata = [];
        $metadata["entity"] = "edited_text";

        /* UPPER PART OF THE SIDEBAR */
        $metadata["tab"] = "Editorial context";
        $metadataTable = ["val" => [], "search" => ["json" => [], "hover" => "", "title" => []], "info" => []];
        $urlTable = ["html" => "", "id" => "", "path" => ""];

        // it is mandatory to add an empty string to the values property if we want to display "No information provided" when metadata is missing
        $defRepo = $this->getEntityManager()->getRepository(E\Definition::class);

        /* TITLE */
        $metadata["title"] = $editedText->getTitle() ? $editedText->getTitle() : "<span class='noInfo'>No title defined</span>";

        /* TABLE TYPE */
        $tableTypeName = $defRepo->getInterfaceName("tableType");
        $metadata[$tableTypeName] = $metadataTable;

        $tableType = $editedText->getTableType();
        if ($tableType) {
            $metadata[$tableTypeName]["val"][] = $urlTable;
            $metadata[$tableTypeName]["val"][0]["html"] = $tableType->toPublicString();
            $metadata[$tableTypeName]["val"][0]["id"] = $tableType->getId();
            $metadata[$tableTypeName]["val"][0]["path"] = "tamas_astro_viewTableType";

            $metadata[$tableTypeName]["search"]["hover"] = "All editions that belong to the same $tableTypeName";
            $filter = QG::newMatchFilter("table_type.id", $tableType->getId());
            $metadata[$tableTypeName]["search"]["json"][] = QG::setFilters([$filter]);
            $metadata[$tableTypeName]["search"]["title"][] = "All editions whose subject is " . $tableType->toPublicTitle();
        }

        /* TABLE CONTENT(S) UNITS */
        $tables = $editedText->getTableContents()->toArray();
        $tableContentName = $defRepo->getInterfaceName("tableContent", count($tables) > 1);
        $metadata[$tableContentName] = $metadataTable;
        $firstMonth = null;

        foreach ($tables as $table){
            if ($table->getPublic()){
                $metadata[$tableContentName]["val"][] = $table->getUnits();

                if ($table->getMeanMotion() && $table->getArgument1NumberUnit()){
                    if ($table->getArgument1NumberUnit()->getUnit() == "month"){
                        // NOTE : only displays one first month,
                        // NOTE : if there is several month tables, only one first month will appear
                        $firstMonth = $table->getMeanMotion()->getFirstMonth();
                    }
                }
            }
        }

        /* CALENDAR */
        if ($editedText->getEra()) {
            $metadata["calendar"] = $metadataTable;
            $metadata["calendar"]["val"][] = ucfirst($editedText->getEra()->toPublicString($firstMonth));

            $metadata["calendar"]["search"]["hover"] = "All editions using the same calendar and sub-calendar";
            $filter = QG::newMatchFilter("era", $editedText->getEra()->__toString());
            $metadata["calendar"]["search"]["json"][] = QG::setFilters([$filter]);
            $metadata["calendar"]["search"]["title"][] = "All editions using " . ucfirst($editedText->getEra()->__toString()) . " as calendar";
        }

        /* EDITION TYPE */
        $metadata["type"] = $metadataTable;
        if ($editedText->getType()) {
            $metadata["type"]["val"][] = "Type " . ucfirst($editedText->getType());
            $metadata["type"]["info"][] = E\EditedText::getEditionTypeDefinition($editedText->getType());
        }

        /* DATE */
        $metadata["date"] = $metadataTable;
        $metadata["date"]["val"][] = $editedText->getDate() ? $editedText->getDate() : "";

        /* HISTORIAN */
        $metadata["intellectual author"] = $metadataTable;

        $authors = $editedText->getHistorians();
        $nAuthors = count($authors) <= 1 ? "" : "s";
        $metadata["intellectual author$nAuthors"]["val"] = count($authors) == 0 ? [""] : [];
        $metadata["intellectual author$nAuthors"]["search"]["hover"] = "All editions from the same intellectual author";
        foreach ($authors as $author) {
            $metadata["intellectual author$nAuthors"]["val"][] = $author->__toString();
            $filter = QG::newMultiMatchFilter(["historian.kibana_id.keyword", "secondary_source.historian.kibana_id.keyword"], "Historian" . $author->getId());
            $metadata["intellectual author$nAuthors"]["search"]["json"][] = QG::setFilters([$filter]);
            $metadata["intellectual author$nAuthors"]["search"]["title"][] = "All editions from " . $author->__toString();
        }

        /* SECONDARY SOURCE */
        $metadata["secondary source"] = $metadataTable;

        if ($editedText->getSecondarySource()) {
            $metadata["secondary source"]["val"][] = $editedText->getSecondarySource()->getTitle();
        } else {
            $metadata["secondary source"]["val"][] = "<span class='noInfo'>This edition was published natively digital</span>";
        }

        /* JOURNAL */
        if ($editedText->getSecondarySource()) {
            if ($editedText->getSecondarySource()->getJournal()) {
                $metadata["journal"] = $metadataTable;
                $metadata["journal"]["val"][] = $editedText->getSecondarySource()->getJournal()->toPublicString();
            }
        }

        /* USER (username/id) */
        $metadata["author of the record"] = $metadataTable;
        $metadata["author of the record"]["val"][] = $editedText->getCreatedBy()->toPublicString();

        return $metadata;
    }
}
